<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  
  <title>activity 的启动 | 霜白</title>
  <meta name="author" content="huronghui" />

  
  <meta name="description" content="android" />
  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <meta property="og:title" content="activity 的启动" />
  <meta property="og:site_name" content="霜白" />

  
  

  
    <meta property="og:image" content="undefined" />
  

  
  <link href="/css/images/favicon.ico" rel="icon" />
  

  <link rel="alternate" href="/atom.xml" title="霜白" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">霜白</a></h1>
  <h2><a href="/">栀年年年</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-16T11:10:11.000Z"><a href="/2016/04/16/activity-的启动/">2016-04-16</a></time>
      
      
  
    <h1 class="title">activity 的启动</h1>
  

    </header>
    <div class="entry">
      
        <p>本节主要讲的是 activity 的启动过程，在android系统中，activity 作为四大组件中使用最广泛的组件，做了很多的封装，因此，我们在创建打开一个activity的时候，代码非常简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(this, Demo.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p>
<p>这样一个新的activity就会出现在我们的面前，那么这短短的两行代码后面，到底系统做了哪些工作呢？ 系统又是什么时候创建的这个activity呢？我们在新的activity的onCreate()函数中设置了布局，那么这个函数又是什么时候被回调的呢？这短短的两行代码当然看不出什么，我们还是要进入源码分析一下(源码位置：frameworks\base\core\java\android\app\activity)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void startActivity(Intent intent, Bundle options) &#123;</span><br><span class="line">       if (options != null) &#123;</span><br><span class="line">           startActivityForResult(intent, -1, options);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           startActivityForResult(intent, -1);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p> 上面的代码可以看出，不管我们传入的参数怎么样，最总都会调用 startActivityForResult()函数，ok，锁定到这个函数的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void startActivityForResult(Intent intent, int requestCode, Bundle options) &#123;</span><br><span class="line">        if (mParent == null) &#123;</span><br><span class="line">    Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(this, mMainThread.getApplicationThread(), mToken, this,</span><br><span class="line">                    intent, requestCode, options);</span><br><span class="line">                    </span><br><span class="line">            if (ar != null) &#123;</span><br><span class="line">    mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (requestCode &gt;= 0) &#123;</span><br><span class="line">                mStartedActivity = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final View decor = mWindow != null ? mWindow.peekDecorView() : null;</span><br><span class="line">            if (decor != null) &#123;</span><br><span class="line">                decor.cancelPendingInputEvents();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (options != null) &#123;</span><br><span class="line">                mParent.startActivityFromChild(this, intent, requestCode, options);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mParent.startActivityFromChild(this, intent, requestCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p> 上面的代码中，我们关注的主要是  mParent == null 的情况，因为 mParent 是ActivityGroup，这在 API 13中就已经不怎么用了，系统推荐使用fragment来代替 ActivityGroup，上面代码中我们要关注的是 mMainThread.getApplicationThread()，这个函数返回的是一个 ApplicationThread类，我们在这边先记着，接着继续分析 Instrumentation 的 execStartActivity 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public ActivityResult execStartActivity(</span><br><span class="line">          Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">          Intent intent, int requestCode, Bundle options) &#123;</span><br><span class="line">      IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">      if (mActivityMonitors != null) &#123;</span><br><span class="line">          synchronized (mSync) &#123;</span><br><span class="line">              final int N = mActivityMonitors.size();</span><br><span class="line">              for (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">                  final ActivityMonitor am = mActivityMonitors.get(i);</span><br><span class="line">                  if (am.match(who, null, intent)) &#123;</span><br><span class="line">                      am.mHits++;</span><br><span class="line">                      if (am.isBlocking()) &#123;</span><br><span class="line">                          return requestCode &gt;= 0 ? am.getResult() : null;</span><br><span class="line">                      &#125;</span><br><span class="line">                      break;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      try &#123;</span><br><span class="line">          intent.migrateExtraStreamToClipData();</span><br><span class="line">          intent.prepareToLeaveProcess();</span><br><span class="line">          int result = ActivityManagerNative.getDefault()</span><br><span class="line">              .startActivity(</span><br><span class="line">              whoThread, who.getBasePackageName(), intent,                       intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null,</span><br><span class="line">                      requestCode, 0, null, null, options);</span><br><span class="line">          checkStartActivityResult(result, intent);</span><br><span class="line">      &#125; catch (RemoteException e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p> 从代码中可以看出，activity的启动主要是由ActivityManagerNative.getDefault() 的 startActivity 这个方法完成的，那么 ActivityManagerNative.getDefault() 是谁呢？ 跟踪代码可以知道，返回的是一个IActivityManager类型的数据，看了这个名字，我们可以理解了，这是一个Binder 类型的数据，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static public IActivityManager getDefault() &#123;</span><br><span class="line">      return gDefault.get();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">      protected IActivityManager create() &#123;</span><br><span class="line">          IBinder b = ServiceManager.getService(&quot;activity&quot;);</span><br><span class="line">          if (false) &#123;</span><br><span class="line">              Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b);</span><br><span class="line">          &#125;</span><br><span class="line">          IActivityManager am = asInterface(b);</span><br><span class="line">          if (false) &#123;</span><br><span class="line">              Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am);</span><br><span class="line">          &#125;</span><br><span class="line">          return am;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<p> 这样应该就很直观了，我们从 ServiceManager 中取出一个service 名字叫 activity，so，getDefault()返回的是一个Binder类型，IActivityManager的具体实现的一个类，类名叫 ActivityManagerService ，看代码中，我们同样可以发现，AMS(ActivityManagerService 的缩写) 是一个单例以及工厂模式，SingleTon 是android自己封装的一个单例类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> public abstract class Singleton&lt;T&gt; &#123;</span><br><span class="line">    private T mInstance;</span><br><span class="line"></span><br><span class="line">    protected abstract T create();</span><br><span class="line"></span><br><span class="line">    public final T get() &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mInstance == null) &#123;</span><br><span class="line">                mInstance = create();</span><br><span class="line">            &#125;</span><br><span class="line">            return mInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，现在已经走到了 ActivityManagerService 的startActivity中，再继续跟踪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final int startActivity(IApplicationThread caller, String callingPackage,</span><br><span class="line">          Intent intent, String resolvedType, IBinder resultTo,</span><br><span class="line">          String resultWho, int requestCode, int startFlags,</span><br><span class="line">          String profileFile, ParcelFileDescriptor profileFd, Bundle options) &#123;</span><br><span class="line">      return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">              resultWho, requestCode,</span><br><span class="line">              startFlags, profileFile, profileFd, options, UserHandle.getCallingUserId());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>紧接着 startActivityAsUser() 方法会调用startActivityAndWait()，然后会调用 ActivityStackSupervisor 的 startActivityAndWait()方法，这是已经从 AMS 转移到 ActivityStackSupervisor 的方法之中了，继续追踪下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">final int startActivityMayWait(IApplicationThread caller, int callingUid,</span><br><span class="line">           String callingPackage, Intent intent, String resolvedType, IBinder resultTo,</span><br><span class="line">           String resultWho, int requestCode, int startFlags, String profileFile,</span><br><span class="line">           ParcelFileDescriptor profileFd, WaitResult outResult, Configuration config,</span><br><span class="line">           Bundle options, int userId) &#123;</span><br><span class="line">           </span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      //将我们传递的数据进行封装，把 intent，启动的flag，id等持久化</span><br><span class="line">       ActivityInfo aInfo = resolveActivity(intent, resolvedType, startFlags, profileFile, profileFd, userId);</span><br><span class="line"></span><br><span class="line">          ....</span><br><span class="line"></span><br><span class="line">       //此处又开始转移启动的函数，跳转到了 startActivityLocked 函数之中</span><br><span class="line">       int res = startActivityLocked(caller, intent, resolvedType,aInfo, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, startFlags, options,componentSpecified, null);</span><br><span class="line"></span><br><span class="line">           ...</span><br><span class="line"></span><br><span class="line">           return res;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码中可以看出：startActivityMayWait 函数核心在于封装了我们传入的参数，创建了一个 ActivityInfo 类进行封装，然后将后续处理交给startActivityLocked()函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//该函数的主要作用是 创建了目标activity的 ActivityRecord</span><br><span class="line">  final int startActivityLocked(IApplicationThread caller,</span><br><span class="line">  Intent intent, String resolvedType, ActivityInfo aInfo, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">  int callingPid, int callingUid, String callingPackage, int startFlags, Bundle options,boolean componentSpecified, ActivityRecord[] outActivity) &#123;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">    //将acitivy的启动消息疯转在 ActivityRecord 中</span><br><span class="line">      ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage,intent, resolvedType, aInfo, mService.mConfiguration,resultRecord, resultWho, requestCode, componentSpecified, this);</span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line">      </span><br><span class="line">       //在此处会在调用函数来创建activity</span><br><span class="line">      err = startActivityUncheckedLocked(r, sourceRecord, startFlags, true, options);</span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line">      </span><br><span class="line">       return err;</span><br></pre></td></tr></table></figure></p>
<p> 就知道不会这么顺利，startActivityLocked 做了更进一步的封装，将 source 和 result 的activity的信息封装进了 ActivityRecord 类中，并传入startActivityUncheckedLocked函数 做下一步处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br></pre></td><td class="code"><pre><span class="line">final int startActivityUncheckedLocked(ActivityRecord r,</span><br><span class="line">ActivityRecord sourceRecord, int startFlags, boolean doResume,Bundle options) &#123; </span><br><span class="line"> final Intent intent = r.intent;</span><br><span class="line">       final int callingUid = r.launchedFromUid;</span><br><span class="line"></span><br><span class="line">       //启动的标记</span><br><span class="line">       int launchFlags = intent.getFlags();</span><br><span class="line"></span><br><span class="line">	//如果lauching Activity 没有明确指出这个Activity要自动启动的话，</span><br><span class="line">	//我们就要在执行onPause函数之前执行onUseLeaving函数</span><br><span class="line">       mUserLeaving = (launchFlags&amp;Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;</span><br><span class="line">       if (DEBUG_USER_LEAVING) </span><br><span class="line">		Slog.v(TAG, &quot;startActivity() =&gt; mUserLeaving=&quot; + mUserLeaving);</span><br><span class="line"></span><br><span class="line">	//如果laucher 没有要求在此时立即启动该Activity，</span><br><span class="line">	//那么 r.delayedResume = true（表示可以延迟resume），</span><br><span class="line">	//当查找最上层正在运行的Activity的时候就可以跳过它了。</span><br><span class="line">       if (!doResume) &#123;</span><br><span class="line">           r.delayedResume = true;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //判断启动activity的方式</span><br><span class="line">       ActivityRecord notTop = (launchFlags&amp;Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">       if ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) &#123;</span><br><span class="line">           ActivityRecord checkedCaller = sourceRecord;</span><br><span class="line">           if (checkedCaller == null) &#123;</span><br><span class="line">               checkedCaller = getFocusedStack().topRunningNonDelayedActivityLocked(notTop);</span><br><span class="line">           &#125;</span><br><span class="line">           if (!checkedCaller.realActivity.equals(r.realActivity)) &#123;</span><br><span class="line">               // Caller is not the same as launcher, so always needed.</span><br><span class="line">               startFlags &amp;= ~ActivityManager.START_FLAG_ONLY_IF_NEEDED;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      //设置要启动的activity的启动模式，并设置是否需要新建一个 Task</span><br><span class="line"></span><br><span class="line">   //下面是三种需要创建新的TASK的情况：</span><br><span class="line">   // (1) sourceRecord=null说明要启动的Activity并不是由一个程序启动的，这时候我们总是启动一个新的TASK。</span><br><span class="line">   //（forcing &quot; +  &quot;Intent.FLAG_ACTIVITY_NEW_TASK）；</span><br><span class="line">   //（2）Launcher的Activity是SingleInstance模式</span><br><span class="line">   // (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE)；</span><br><span class="line">   //（3）r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE || </span><br><span class="line">   // r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK。</span><br><span class="line">   //统一处理：设置launchFlags标志。（launchFlags标志决定着是否新创建Task等。）</span><br><span class="line">       if (sourceRecord == null) &#123;</span><br><span class="line">          </span><br><span class="line">           if ((launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == 0) &#123;</span><br><span class="line">               Slog.w(TAG, &quot;startActivity called from non-Activity context; forcing &quot; +</span><br><span class="line">                       &quot;Intent.FLAG_ACTIVITY_NEW_TASK for: &quot; + intent);</span><br><span class="line">               launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) &#123;</span><br><span class="line">          </span><br><span class="line">           launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line">       &#125; else if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE</span><br><span class="line">               || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) &#123;</span><br><span class="line">           </span><br><span class="line">           launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">	//创建ActivityStack sourceStack表示sourceRecord所在的TASK所在的Stack。</span><br><span class="line">	//并通过判断sourceRecord是否还在以及如果在的话，状态如何，来设置launchFlags标志。</span><br><span class="line">       </span><br><span class="line">       final ActivityStack sourceStack;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	//如果sourceRecord已经处于finishing状态，那么他所在的Task就很有可能已经为空或者即将为空。</span><br><span class="line">	//我们就不能盲目throw it in to that task。</span><br><span class="line">	</span><br><span class="line">       if (sourceRecord != null) &#123;</span><br><span class="line">           if (sourceRecord.finishing) &#123;</span><br><span class="line">              </span><br><span class="line">               if ((launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == 0) &#123;</span><br><span class="line">                   Slog.w(TAG, &quot;startActivity called from finishing &quot; + sourceRecord</span><br><span class="line">                           + &quot;; forcing &quot; + &quot;Intent.FLAG_ACTIVITY_NEW_TASK for: &quot; + intent);</span><br><span class="line">                   launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line">               &#125;</span><br><span class="line">               sourceRecord = null;</span><br><span class="line">               sourceStack = null;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               sourceStack = sourceRecord.task.stack;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           sourceStack = null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	   </span><br><span class="line">      //如果新的Activity要新创建Task而启动，而且原先的Activity需要返回结果，</span><br><span class="line">      //这种情况下，调用函数r.resultTo.task.stack.sendActivityResultLocked（）</span><br><span class="line">      //将 Activity.RESULT_CANCELED结果返回给launcher,并将resultTo置为null，resultTo的使命结束了。</span><br><span class="line"></span><br><span class="line">   //如果是通过startActivityForResult()来启动activity，</span><br><span class="line">   //并且intent添加了FLAG_ACTIVITY_NEW_TASK这个flag，</span><br><span class="line">   //那么提前把result返回。</span><br><span class="line">   //正常情况是在next activity finish时才把result返回给pre activity；  </span><br><span class="line">       if (r.resultTo != null &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0) &#123;</span><br><span class="line">          </span><br><span class="line">           Slog.w(TAG, &quot;Activity is launching as a new task, so cancelling activity result.&quot;);</span><br><span class="line">           r.resultTo.task.stack.sendActivityResultLocked(-1,</span><br><span class="line">                   r.resultTo, r.resultWho, r.requestCode,</span><br><span class="line">               Activity.RESULT_CANCELED, null);</span><br><span class="line">           r.resultTo = null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       boolean addingToTask = false;</span><br><span class="line">       boolean movedHome = false;</span><br><span class="line">       TaskRecord reuseTask = null;</span><br><span class="line">       ActivityStack targetStack;</span><br><span class="line"></span><br><span class="line">	//当我们需要启动的activity不是新建一个新的task的时候，就要从之前的task中找到这个activity</span><br><span class="line">	//意思就是如果我们启动的activity是 singleInstance 或者 singleTake的时候，我们可以再我们的task</span><br><span class="line">	//中找到目标activity</span><br><span class="line"></span><br><span class="line">	//如果不启动新的Task，那么寻找Activity所属的Task并移到前台。</span><br><span class="line">       if (((launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &amp;&amp;</span><br><span class="line">               (launchFlags&amp;Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0)</span><br><span class="line">               || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK</span><br><span class="line">               || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) &#123;</span><br><span class="line"></span><br><span class="line">		//从所有Stack中的所有Task中的Activity中查找看能否找到要启动的Activity，</span><br><span class="line">		//根据要启动的Activity启动模式是否是SingleInstance所采用的搜索方法是不一样的。</span><br><span class="line">           if (r.resultTo == null) &#123;</span><br><span class="line"></span><br><span class="line">			//检查是否有Task需要被带到前台。如果检测到就赋值给ActivityRecord intentActivity，</span><br><span class="line">			//就不需要启动新的TASK了，否则，intentActivity为空，需要创建新的TASK。</span><br><span class="line">			//这里的intentActivity就是老罗分析里面的taskTop。</span><br><span class="line"></span><br><span class="line">			//当 activity 的启动方式是 singleInstance 的时候 ，找到目标task</span><br><span class="line">			</span><br><span class="line">               ActivityRecord intentActivity = r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE</span><br><span class="line">                       ? findTaskLocked(r)</span><br><span class="line">                       : findActivityLocked(intent, r.info);</span><br><span class="line"></span><br><span class="line">			//如果找到的话，就将找到的task设为我们的目标task</span><br><span class="line">			//intentActivity 所在的TASK就是要启动的Activity所在的Task，</span><br><span class="line">			//要启动的Activity所在的Stack targetStack就是intentActivity所在的Stack。</span><br><span class="line">			</span><br><span class="line">               if (intentActivity != null) &#123;</span><br><span class="line"></span><br><span class="line">				//如果我们源task为null，那么我们找到的task就是我们的目标task，</span><br><span class="line">				//否则两个task是否是同一个task</span><br><span class="line">                   if (r.task == null) &#123;</span><br><span class="line">                       r.task = intentActivity.task;</span><br><span class="line">                   &#125;</span><br><span class="line">				</span><br><span class="line">                   targetStack = intentActivity.task.stack;</span><br><span class="line">                   targetStack.mLastPausedActivity = null;</span><br><span class="line">                   if (DEBUG_TASKS) Slog.d(TAG, &quot;Bring to front target: &quot; + targetStack</span><br><span class="line">                           + &quot; from &quot; + intentActivity);</span><br><span class="line">                   moveHomeStack(targetStack.isHomeStack());</span><br><span class="line">				</span><br><span class="line">                   if (intentActivity.task.intent == null) &#123;</span><br><span class="line">                     </span><br><span class="line">                       intentActivity.task.setIntent(intent, r.info);</span><br><span class="line">                   &#125;</span><br><span class="line">                  </span><br><span class="line">                   final ActivityStack lastStack = getLastStack();</span><br><span class="line">                   ActivityRecord curTop = lastStack == null?</span><br><span class="line">                           null : lastStack.topRunningNonDelayedActivityLocked(notTop);</span><br><span class="line">                   if (curTop != null &amp;&amp; (curTop.task != intentActivity.task ||</span><br><span class="line">                           curTop.task != lastStack.topTask())) &#123;</span><br><span class="line">                       r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);</span><br><span class="line">                       if (sourceRecord == null || (sourceStack.topActivity() != null &amp;&amp;</span><br><span class="line">                               sourceStack.topActivity().task == sourceRecord.task)) &#123;</span><br><span class="line">                          </span><br><span class="line">                           movedHome = true;</span><br><span class="line">                           if ((launchFlags &amp;</span><br><span class="line">                                   (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME))</span><br><span class="line">                                   == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) &#123;</span><br><span class="line">                               // Caller wants to appear on home activity.</span><br><span class="line">                               intentActivity.task.mOnTopOfHome = true;</span><br><span class="line">                           &#125;</span><br><span class="line"></span><br><span class="line">						//这一步，将已经存在的我们的目标Task终于被移动到了前台！</span><br><span class="line">						//参数intentActivity.task就是我们搜索出来的我们要启动的Activity所在的Task，</span><br><span class="line">						//r就是我们要启动的ActivityRecord。</span><br><span class="line">                           targetStack.moveTaskToFrontLocked(intentActivity.task, r, options);</span><br><span class="line">                           options = null;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                  </span><br><span class="line">                   if ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) &#123;</span><br><span class="line">                       intentActivity = targetStack.resetTaskIfNeededLocked(intentActivity, r);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">				//如果当前的启动的activity就是在我们的栈中的时候，我们直接启动就可以了</span><br><span class="line">                   if ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) &#123;</span><br><span class="line">                     </span><br><span class="line">                       if (doResume) &#123;</span><br><span class="line">                           resumeTopActivitiesLocked(targetStack, null, options);</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           ActivityOptions.abort(options);</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (r.task == null)  Slog.v(TAG,</span><br><span class="line">                               &quot;startActivityUncheckedLocked: task left null&quot;,</span><br><span class="line">                               new RuntimeException(&quot;here&quot;).fillInStackTrace());</span><br><span class="line">                       return ActivityManager.START_RETURN_INTENT_TO_CALLER;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">				//如果Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_CLEAR_TASK被置位，</span><br><span class="line">				//那么将除此之外的所有Task都清除掉：</span><br><span class="line">                   if ((launchFlags &amp;</span><br><span class="line">                           (Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_CLEAR_TASK))</span><br><span class="line">                           == (Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_CLEAR_TASK)) &#123;</span><br><span class="line">                      </span><br><span class="line">                       reuseTask = intentActivity.task;</span><br><span class="line">                       reuseTask.performClearTaskLocked();</span><br><span class="line">                       reuseTask.setIntent(r.intent, r.info);</span><br><span class="line">                   &#125; else if ((launchFlags&amp;Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0</span><br><span class="line">                           || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK</span><br><span class="line">                           || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) &#123;</span><br><span class="line">                       </span><br><span class="line">                       ActivityRecord top =</span><br><span class="line">                               intentActivity.task.performClearTaskLocked(r, launchFlags);</span><br><span class="line">                       if (top != null) &#123;</span><br><span class="line">                           if (top.frontOfTask) &#123;</span><br><span class="line">                              </span><br><span class="line">                               top.task.setIntent(r.intent, r.info);</span><br><span class="line">                           &#125;</span><br><span class="line">                           ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,</span><br><span class="line">                                   r, top.task);</span><br><span class="line">                           top.deliverNewIntentLocked(callingUid, r.intent);</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                          </span><br><span class="line">                           addingToTask = true;</span><br><span class="line">                          </span><br><span class="line">                           sourceRecord = intentActivity;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; else if (r.realActivity.equals(intentActivity.task.realActivity)) &#123;</span><br><span class="line">                      </span><br><span class="line">                       if (((launchFlags&amp;Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0</span><br><span class="line">                               || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP)</span><br><span class="line">                               &amp;&amp; intentActivity.realActivity.equals(r.realActivity)) &#123;</span><br><span class="line">                           ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r,</span><br><span class="line">                                   intentActivity.task);</span><br><span class="line">                           if (intentActivity.frontOfTask) &#123;</span><br><span class="line">                               intentActivity.task.setIntent(r.intent, r.info);</span><br><span class="line">                           &#125;</span><br><span class="line">                           intentActivity.deliverNewIntentLocked(callingUid, r.intent);</span><br><span class="line">                       &#125; else if (!r.intent.filterEquals(intentActivity.task.intent)) &#123;</span><br><span class="line">                          </span><br><span class="line">                           addingToTask = true;</span><br><span class="line">                           sourceRecord = intentActivity;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; else if ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) &#123;</span><br><span class="line">                      </span><br><span class="line">                       addingToTask = true;</span><br><span class="line">                       sourceRecord = intentActivity;</span><br><span class="line">                   &#125; else if (!intentActivity.task.rootWasReset) &#123;</span><br><span class="line">                      </span><br><span class="line">                       intentActivity.task.setIntent(r.intent, r.info);</span><br><span class="line">                   &#125;</span><br><span class="line">                   if (!addingToTask &amp;&amp; reuseTask == null) &#123;</span><br><span class="line">                       </span><br><span class="line">                       if (doResume) &#123;</span><br><span class="line">                           targetStack.resumeTopActivityLocked(null, options);</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           ActivityOptions.abort(options);</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (r.task == null)  Slog.v(TAG,</span><br><span class="line">                           &quot;startActivityUncheckedLocked: task left null&quot;,</span><br><span class="line">                           new RuntimeException(&quot;here&quot;).fillInStackTrace());</span><br><span class="line">                       return ActivityManager.START_TASK_TO_FRONT;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">       //判断当前要启动的activity 是否就是栈顶的activity，如果是的话，就不用再重新启动了</span><br><span class="line"></span><br><span class="line">	//这段代码的逻辑是看一下，当前在堆栈顶端的Activity是否就是即将要启动的Activity，</span><br><span class="line">	//有些情况下，如果即将要启动的Activity就在堆栈的顶端，</span><br><span class="line">	//那么，就不会重新启动这个Activity的别一个实例了，</span><br><span class="line">	//具体可以参考官方网站http://developer.android.com/reference/android/content/pm/ActivityInfo.html。</span><br><span class="line">       if (r.packageName != null) &#123;</span><br><span class="line">          </span><br><span class="line">           ActivityStack topStack = getFocusedStack();</span><br><span class="line"></span><br><span class="line">		//topRunningNonDelayedActivityLocked 返回的是当前栈顶的activity</span><br><span class="line">           ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(notTop);</span><br><span class="line">           if (top != null &amp;&amp; r.resultTo == null) &#123;</span><br><span class="line">               if (top.realActivity.equals(r.realActivity) &amp;&amp; top.userId == r.userId) &#123;</span><br><span class="line">                   if (top.app != null &amp;&amp; top.app.thread != null) &#123;</span><br><span class="line">                       if ((launchFlags&amp;Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0</span><br><span class="line">                           || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP</span><br><span class="line">                           || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) &#123;</span><br><span class="line">                           ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, top,</span><br><span class="line">                                   top.task);</span><br><span class="line">                          </span><br><span class="line">                           topStack.mLastPausedActivity = null;</span><br><span class="line">                           if (doResume) &#123;</span><br><span class="line">                               resumeTopActivitiesLocked();</span><br><span class="line">                           &#125;</span><br><span class="line">                           ActivityOptions.abort(options);</span><br><span class="line">                           if ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) &#123;</span><br><span class="line">                              </span><br><span class="line">                               if (r.task == null)  Slog.v(TAG,</span><br><span class="line">                                   &quot;startActivityUncheckedLocked: task left null&quot;,</span><br><span class="line">                                   new RuntimeException(&quot;here&quot;).fillInStackTrace());</span><br><span class="line">                               return ActivityManager.START_RETURN_INTENT_TO_CALLER;</span><br><span class="line">                           &#125;</span><br><span class="line">                           top.deliverNewIntentLocked(callingUid, r.intent);</span><br><span class="line">                           if (r.task == null)  Slog.v(TAG,</span><br><span class="line">                               &quot;startActivityUncheckedLocked: task left null&quot;,</span><br><span class="line">                               new RuntimeException(&quot;here&quot;).fillInStackTrace());</span><br><span class="line">                           return ActivityManager.START_DELIVERED_TO_TOP;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           if (r.resultTo != null) &#123;</span><br><span class="line">               r.resultTo.task.stack.sendActivityResultLocked(-1, r.resultTo, r.resultWho,</span><br><span class="line">                       r.requestCode, Activity.RESULT_CANCELED, null);</span><br><span class="line">           &#125;</span><br><span class="line">           ActivityOptions.abort(options);</span><br><span class="line">           if (r.task == null)  Slog.v(TAG,</span><br><span class="line">               &quot;startActivityUncheckedLocked: task left null&quot;,</span><br><span class="line">               new RuntimeException(&quot;here&quot;).fillInStackTrace());</span><br><span class="line">           return ActivityManager.START_CLASS_NOT_FOUND;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       boolean newTask = false;</span><br><span class="line">       boolean keepCurTransition = false;</span><br><span class="line"></span><br><span class="line">       // Should this be considered a new task?</span><br><span class="line">       //我们需要创建一个新的task来启动这个activity，下面开始创建这个新的task</span><br><span class="line">       if (r.resultTo == null &amp;&amp; !addingToTask</span><br><span class="line">               &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0) &#123;</span><br><span class="line">           targetStack = adjustStackFocus(r);</span><br><span class="line">           moveHomeStack(targetStack.isHomeStack());</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		//在此时，若前面的reuseTask为空，在targetStack中创建新的Task。</span><br><span class="line">           if (reuseTask == null) &#123;</span><br><span class="line">               r.setTask(targetStack.createTaskRecord(getNextTaskId(), r.info, intent, true),</span><br><span class="line">                       null, true);</span><br><span class="line">               if (DEBUG_TASKS) Slog.v(TAG, &quot;Starting new activity &quot; + r + &quot; in new task &quot; +</span><br><span class="line">                       r.task);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               r.setTask(reuseTask, reuseTask, true);</span><br><span class="line">           &#125;</span><br><span class="line">           newTask = true;</span><br><span class="line">           if (!movedHome) &#123;</span><br><span class="line">               if ((launchFlags &amp;</span><br><span class="line">                       (Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_TASK_ON_HOME))</span><br><span class="line">                       == (Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_TASK_ON_HOME)) &#123;</span><br><span class="line">                  </span><br><span class="line">                   r.task.mOnTopOfHome = true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else if (sourceRecord != null) &#123;</span><br><span class="line">           TaskRecord sourceTask = sourceRecord.task;</span><br><span class="line">           targetStack = sourceTask.stack;</span><br><span class="line">           moveHomeStack(targetStack.isHomeStack());</span><br><span class="line">           if (!addingToTask &amp;&amp;</span><br><span class="line">                   (launchFlags&amp;Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) &#123;</span><br><span class="line">              </span><br><span class="line">               ActivityRecord top = sourceTask.performClearTaskLocked(r, launchFlags);</span><br><span class="line">               keepCurTransition = true;</span><br><span class="line">               if (top != null) &#123;</span><br><span class="line">                   ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task);</span><br><span class="line">                   top.deliverNewIntentLocked(callingUid, r.intent);</span><br><span class="line">                 </span><br><span class="line">                   targetStack.mLastPausedActivity = null;</span><br><span class="line">                   if (doResume) &#123;</span><br><span class="line">                       targetStack.resumeTopActivityLocked(null);</span><br><span class="line">                   &#125;</span><br><span class="line">                   ActivityOptions.abort(options);</span><br><span class="line">                   if (r.task == null)  Slog.w(TAG,</span><br><span class="line">                       &quot;startActivityUncheckedLocked: task left null&quot;,</span><br><span class="line">                       new RuntimeException(&quot;here&quot;).fillInStackTrace());</span><br><span class="line">                   return ActivityManager.START_DELIVERED_TO_TOP;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else if (!addingToTask &amp;&amp;</span><br><span class="line">                   (launchFlags&amp;Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) &#123;</span><br><span class="line">              </span><br><span class="line">               final ActivityRecord top = sourceTask.findActivityInHistoryLocked(r);</span><br><span class="line">               if (top != null) &#123;</span><br><span class="line">                   final TaskRecord task = top.task;</span><br><span class="line">                   task.moveActivityToFrontLocked(top);</span><br><span class="line">                   ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r, task);</span><br><span class="line">                   top.updateOptionsLocked(options);</span><br><span class="line">                   top.deliverNewIntentLocked(callingUid, r.intent);</span><br><span class="line">                   targetStack.mLastPausedActivity = null;</span><br><span class="line">                   if (doResume) &#123;</span><br><span class="line">                       targetStack.resumeTopActivityLocked(null);</span><br><span class="line">                   &#125;</span><br><span class="line">                   return ActivityManager.START_DELIVERED_TO_TOP;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">          </span><br><span class="line">           r.setTask(sourceTask, sourceRecord.thumbHolder, false);</span><br><span class="line">           if (DEBUG_TASKS) Slog.v(TAG, &quot;Starting new activity &quot; + r</span><br><span class="line">                   + &quot; in existing task &quot; + r.task + &quot; from source &quot; + sourceRecord);</span><br><span class="line"></span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         </span><br><span class="line">           targetStack = adjustStackFocus(r);</span><br><span class="line">           moveHomeStack(targetStack.isHomeStack());</span><br><span class="line">           ActivityRecord prev = targetStack.topActivity();</span><br><span class="line">           r.setTask(prev != null ? prev.task</span><br><span class="line">                   : targetStack.createTaskRecord(getNextTaskId(), r.info, intent, true),</span><br><span class="line">                   null, true);</span><br><span class="line">           if (DEBUG_TASKS) Slog.v(TAG, &quot;Starting new activity &quot; + r</span><br><span class="line">                   + &quot; in new guessed &quot; + r.task);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">	//赋权限，这里的mService就是AMS</span><br><span class="line">       mService.grantUriPermissionFromIntentLocked(callingUid, r.packageName,</span><br><span class="line">               intent, r.getUriPermissionsLocked());</span><br><span class="line"></span><br><span class="line">       if (newTask) &#123;</span><br><span class="line">           EventLog.writeEvent(EventLogTags.AM_CREATE_TASK, r.userId, r.task.taskId);</span><br><span class="line">       &#125;</span><br><span class="line">       ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY, r, r.task);</span><br><span class="line">       targetStack.mLastPausedActivity = null;</span><br><span class="line"></span><br><span class="line">	//此时，传进来的 newTask 为false，</span><br><span class="line">	//最后就进入startActivityLocked(r, newTask, doResume)进一步处理了。</span><br><span class="line">       targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);</span><br><span class="line">       mService.setFocusedActivityLocked(r);</span><br><span class="line">       return ActivityManager.START_SUCCESS;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> 这段代码很长，但也很很重要，因为在此处，我们会对我们的源activity 和目标 activity进行 launcherModel 的比较，分析是否需要创建一个Task 来存储目标 activity，并最终调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);</span><br></pre></td></tr></table></figure></p>
<p> 至此，我们流程将会从ActivityStackSupervisor 转移到 ActivityStack 中，继续追踪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">final void startActivityLocked(ActivityRecord r, boolean newTask,</span><br><span class="line">          boolean doResume, boolean keepCurTransition, Bundle options) &#123;</span><br><span class="line">          // ActivityRecord 表示是将要开启的Activity的对象，里面封装了很多的信息，比如所属的 ActivityTask等</span><br><span class="line">//获取到目标Task以及 Task 所在的id</span><br><span class="line">      TaskRecord rTask = r.task;</span><br><span class="line">      final int taskId = rTask.taskId;</span><br><span class="line"></span><br><span class="line">//如果该task在task列表中或者需要重启开启一个task则插入一个task至栈顶，同时调用</span><br><span class="line">// WMS 移动至栈顶</span><br><span class="line">      if (taskForIdLocked(taskId) == null || newTask) &#123;</span><br><span class="line">         </span><br><span class="line">          insertTaskAtTop(rTask);</span><br><span class="line"></span><br><span class="line">	//WMS 是否管理 Task真的调用之栈顶</span><br><span class="line">          mWindowManager.moveTaskToTop(taskId);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      TaskRecord task = null;</span><br><span class="line"></span><br><span class="line">//判断是不是要开启一个新的task，如果不需要的话，就找出这个task的位置</span><br><span class="line">      if (!newTask) &#123;</span><br><span class="line">         </span><br><span class="line">          boolean startIt = true;</span><br><span class="line"></span><br><span class="line">	//从task 历史记录中获取到目标Task</span><br><span class="line">          for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) &#123;</span><br><span class="line">              task = mTaskHistory.get(taskNdx);</span><br><span class="line">              if (task == r.task) &#123;</span><br><span class="line">                 </span><br><span class="line">                  if (!startIt) &#123;</span><br><span class="line">                     ...</span><br><span class="line">                     &#125;</span><br><span class="line">                     </span><br><span class="line">                      if (doResume) &#123;</span><br><span class="line"></span><br><span class="line">	//在返回到 ActivityStackSupervisor 类中</span><br><span class="line">          mStackSupervisor.resumeTopActivitiesLocked();</span><br><span class="line">      &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p> 看，流程又将回到 ActivityStackSupervisor 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target,</span><br><span class="line">           Bundle targetOptions) &#123;</span><br><span class="line">       if (targetStack == null) &#123;</span><br><span class="line">           targetStack = getFocusedStack();</span><br><span class="line">       &#125;</span><br><span class="line">       boolean result = false;</span><br><span class="line">       for (int stackNdx = mStacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123;</span><br><span class="line">           final ActivityStack stack = mStacks.get(stackNdx);</span><br><span class="line">           if (isFrontStack(stack)) &#123;</span><br><span class="line"></span><br><span class="line">			//恢复最顶层的Activity</span><br><span class="line">               if (stack == targetStack) &#123;</span><br><span class="line"></span><br><span class="line">				//又回到了 ActivityStack 类的方法中</span><br><span class="line">                   result = stack.resumeTopActivityLocked(target, targetOptions);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   stack.resumeTopActivityLocked(null);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> 最核心的还是调用 ActivityStack 的 resumeTopActivityLocked 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br></pre></td><td class="code"><pre><span class="line">final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) &#123;</span><br><span class="line"></span><br><span class="line">	//注意参数pre在start new activity时的参数值。第一次调用时pre为null；</span><br><span class="line">	//第二次pause后调用resumeTopActivityLocked()时pre为paused activity，不为null。</span><br><span class="line">	</span><br><span class="line">       if (ActivityManagerService.DEBUG_LOCKSCREEN) mService.logLockScreen(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">       //函数先通过调用topRunningActivityLocked函数获得堆栈顶端的Activity，</span><br><span class="line">       //这里就是MainActivity了，之前已经设置好的，保存在next变量中</span><br><span class="line">       </span><br><span class="line">        //①找到一个处于栈顶Task中的顶端activity，</span><br><span class="line">       //且ActivityRecord.finishing==false的activity。前面已经说了，</span><br><span class="line">       //在调用resumeTopActivitiesLocked()之前已经做好了充分的准备，</span><br><span class="line">       //将要被resume的activity肯定已经处在最顶端了。  </span><br><span class="line"> </span><br><span class="line">       ActivityRecord next = topRunningActivityLocked(null);</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">   //接下来把mUserLeaving的保存在本地变量userLeaving中，然后重新设置为false，</span><br><span class="line">   //在前面，mUserLeaving的值为true，因此，这里的userLeaving为true。</span><br><span class="line">  </span><br><span class="line">       final boolean userLeaving = mStackSupervisor.mUserLeaving;</span><br><span class="line">       mStackSupervisor.mUserLeaving = false;</span><br><span class="line"></span><br><span class="line">       if (next == null) &#123;</span><br><span class="line"></span><br><span class="line">		//②如果取出的activity为null，那这个ActivityStack肯定是非Home Stack，</span><br><span class="line">		//因为HomeStack不可能取不出activity的，这个时候只能启动Home Stack中的launcher了。</span><br><span class="line"></span><br><span class="line">           ActivityOptions.abort(options);</span><br><span class="line">           if (DEBUG_STATES) Slog.d(TAG, &quot;resumeTopActivityLocked: No more activities go home&quot;);</span><br><span class="line">           if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">           return mStackSupervisor.resumeHomeActivity(prev);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       next.delayedResume = false;</span><br><span class="line"></span><br><span class="line">       //它首先看要启动的Activity是否就是当前处理Resumed状态的Activity，</span><br><span class="line">       //如果是的话，那就什么都不用做，直接返回就可以了；</span><br><span class="line">       //否则再看一下系统当前是否休眠状态，</span><br><span class="line">       //如果是的话，再看看要启动的Activity是否就是当前处于堆栈顶端的Activity，</span><br><span class="line">       //如果是的话，也是什么都不用做。</span><br><span class="line">       if (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp;</span><br><span class="line">                   mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class="line"></span><br><span class="line">		//③如果栈顶的Activity已经resume了，那么直接返回呀。  </span><br><span class="line"></span><br><span class="line">           mWindowManager.executeAppTransition();</span><br><span class="line">           mNoAnimActivities.clear();</span><br><span class="line">           ActivityOptions.abort(options);</span><br><span class="line">           if (DEBUG_STATES) Slog.d(TAG, &quot;resumeTopActivityLocked: Top activity resumed &quot; + next);</span><br><span class="line">           if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       final TaskRecord nextTask = next.task;</span><br><span class="line">       final TaskRecord prevTask = prev != null ? prev.task : null;</span><br><span class="line">       if (prevTask != null &amp;&amp; prevTask.mOnTopOfHome &amp;&amp; prev.finishing &amp;&amp; prev.frontOfTask) &#123;</span><br><span class="line"></span><br><span class="line">		 //④这个地方逻辑挺复杂的。pre activity被finish掉了，</span><br><span class="line">		 //并且pre activity是该Task中的最后一个Activity，并且该Task是要回到home的。  </span><br><span class="line">		 </span><br><span class="line">           if (DEBUG_STACK)  mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">           if (prevTask == nextTask) &#123;</span><br><span class="line"></span><br><span class="line">			//④这种情况就是next activity与pre activity属于同一Task，</span><br><span class="line">			//也就是说pre activity被finish掉了，但是又加入了新的成员，</span><br><span class="line">			//这个新的成员也就是这个Task中唯一一个Activity。</span><br><span class="line">			//此时便把next activity的frontOfTask设为true便好了。</span><br><span class="line">			</span><br><span class="line">               ArrayList&lt;ActivityRecord&gt; activities = prevTask.mActivities;</span><br><span class="line">               final int numActivities = activities.size();</span><br><span class="line">               for (int activityNdx = 0; activityNdx &lt; numActivities; ++activityNdx) &#123;</span><br><span class="line">                   final ActivityRecord r = activities.get(activityNdx);</span><br><span class="line">                  </span><br><span class="line">                   if (!r.finishing) &#123;</span><br><span class="line">                       r.frontOfTask = true;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else if (prevTask != topTask()) &#123;</span><br><span class="line"></span><br><span class="line">		    //④这种情况便是next activity与pre activity不属于同一个Task，</span><br><span class="line">		    //pre activity被finish掉了，且是pre Task中的最后一个activity。</span><br><span class="line">		    //既然pre Task的mOnTopOfHome属性为true，那么next Task必然要回到Home，</span><br><span class="line">		    //所以需要把next Task的mOnTopOfHome 值置true。</span><br><span class="line"></span><br><span class="line">               final int taskNdx = mTaskHistory.indexOf(prevTask) + 1;</span><br><span class="line">               mTaskHistory.get(taskNdx).mOnTopOfHome = true;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               if (DEBUG_STATES) Slog.d(TAG, &quot;resumeTopActivityLocked: Launching home next&quot;);</span><br><span class="line">               return mStackSupervisor.resumeHomeActivity(prev);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">       if (mService.isSleepingOrShuttingDown()</span><br><span class="line">               &amp;&amp; mLastPausedActivity == next</span><br><span class="line">               &amp;&amp; mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class="line"></span><br><span class="line">			//⑤系统正在睡眠，无须resume Activity，此时直接返回FALSE。  </span><br><span class="line">			</span><br><span class="line">           mWindowManager.executeAppTransition();</span><br><span class="line">           mNoAnimActivities.clear();</span><br><span class="line">           ActivityOptions.abort(options);</span><br><span class="line">           if (DEBUG_STATES) Slog.d(TAG, &quot;resumeTopActivityLocked: Going to sleep and all paused&quot;);</span><br><span class="line">           if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">       if (mService.mStartedUsers.get(next.userId) == null) &#123;</span><br><span class="line">		//⑥判断当前要resume的Activity所属的userID是否已经起来  </span><br><span class="line">		</span><br><span class="line">           Slog.w(TAG, &quot;Skipping resume of top activity &quot; + next</span><br><span class="line">                   + &quot;: user &quot; + next.userId + &quot; is stopped&quot;);</span><br><span class="line">           if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">       //⑥如果要resume一个Activity，那么必然要清掉mStoppingActivities、</span><br><span class="line">       //mGoingToSleepActivities、mWaitingVisibleActivities列表中该Activity </span><br><span class="line">       mStackSupervisor.mStoppingActivities.remove(next);</span><br><span class="line">       mStackSupervisor.mGoingToSleepActivities.remove(next);</span><br><span class="line">       next.sleeping = false;</span><br><span class="line">       mStackSupervisor.mWaitingVisibleActivities.remove(next);</span><br><span class="line"></span><br><span class="line">       //⑥此处调用基本是无效的，因为在startActivity最开始就已经调用过该</span><br><span class="line">       //函数进行创建一个ActivityOptions了。  </span><br><span class="line">       next.updateOptionsLocked(options);</span><br><span class="line"></span><br><span class="line">       if (DEBUG_SWITCH) Slog.v(TAG, &quot;Resuming &quot; + next);</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">       if (!mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class="line"></span><br><span class="line">		//⑥如果pre Activity还没pause完成，那么也直接返回，</span><br><span class="line">		//因为必须pause掉pre Activity才可以resume next Activity。</span><br><span class="line">		</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">	//⑦前面说了，在调用resumeTopActivityLocked()已经做好了Stack、Task等准备，</span><br><span class="line">	//但是还没pause 前一个Stack中的resumed Activity，</span><br><span class="line">	//或者没有pause掉本Stack中resumed activity。</span><br><span class="line">	//此时便进行触发pause操作，然后返回，</span><br><span class="line">	//等待pause完成后调用completePauseLocked()--&gt;resumeTopActivityLocked()再次尝试resume，</span><br><span class="line">	//此时便可继续往下执行。  </span><br><span class="line"></span><br><span class="line">	//上面两个条件(mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED)都不满足，</span><br><span class="line">	//因此，在继续往下执行之前，首先要把当处于Resumed状态的Activity推入Paused状态，</span><br><span class="line">	//然后才可以启动新的Activity。但是在将当前这个Resumed状态的Activity推入Paused状态之前，</span><br><span class="line">	//首先要看一下当前是否有Activity正在进入Pausing状态，</span><br><span class="line">	//如果有的话，当前这个Resumed状态的Activity就要稍后才能进入Paused状态了，</span><br><span class="line">	//这样就保证了所有需要进入Paused状态的Activity串行处理</span><br><span class="line">       //这里没有处于Pausing状态的Activity，即mPausingActivity为null，</span><br><span class="line">       //而且mResumedActivity也不为null，于是就调用startPausingLocked函数把Launcher推入Paused状态去了。</span><br><span class="line"></span><br><span class="line">       //自我感悟:在此处开始，将我们之前正在显示的 activity 执行 pause 操作，可以理解为开始销毁显示的</span><br><span class="line">       //activity，为显示我们要加载的activity 做准备</span><br><span class="line">       boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving);</span><br><span class="line">	</span><br><span class="line">		//同时也是在此调用内，最终调用到应用程序activity的onCreate()函数。</span><br><span class="line">           startPausingLocked(userLeaving, false);</span><br><span class="line">           </span><br><span class="line">           ...</span><br><span class="line"></span><br><span class="line">	//⑦在pause pre Activity后，这个逻辑及下面的逻辑都会调用。	</span><br><span class="line">       if (prev != null &amp;&amp; prev != next) &#123;</span><br><span class="line">           if (!prev.waitingVisible &amp;&amp; next != null &amp;&amp; !next.nowVisible) &#123;</span><br><span class="line"></span><br><span class="line">			//⑦刚pause完pre Activity，next Activity肯定还不可见嘛，</span><br><span class="line">			//这个逻辑自然会走。把pre Activity.waitingVisible=true.</span><br><span class="line">			//这个应该是为过渡动画做准备吧？  </span><br><span class="line">               prev.waitingVisible = true;</span><br><span class="line">               mStackSupervisor.mWaitingVisibleActivities.add(prev);</span><br><span class="line">               if (DEBUG_SWITCH) Slog.v(</span><br><span class="line">                       TAG, &quot;Resuming top, waiting visible to hide: &quot; + prev);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">              </span><br><span class="line">              ...</span><br><span class="line"></span><br><span class="line">       boolean anim = true;</span><br><span class="line">       if (prev != null) &#123;</span><br><span class="line">           if (prev.finishing) &#123;</span><br><span class="line"></span><br><span class="line">			//⑦如果pre Activity已经被finish了，那么直接隐藏pre Activity的窗口好了。</span><br><span class="line">			//如果没有被finish呢？那就先不管，反正next Activity的窗口肯定</span><br><span class="line">			//会覆盖pre Activity的窗口之上。从这个逻辑可以看出一个Activity只有在finish掉时窗口</span><br><span class="line">			//才设为不可见，pause状态窗口是可见的，</span><br><span class="line">			//同时也可以知道Activity切换动画是在resume next Activity时启动的。 </span><br><span class="line"></span><br><span class="line">       ActivityStack lastStack = mStackSupervisor.getLastStack();</span><br><span class="line">       if (next.app != null &amp;&amp; next.app.thread != null) &#123;</span><br><span class="line"></span><br><span class="line">		//⑧ActivityRecord.app的赋值在realStartActivityLocked()完成;</span><br><span class="line">		//如果resume的Activity还未跟进程关联，那么就为null——说白点就是</span><br><span class="line">		//如果resume一个新的activity那么就为null，</span><br><span class="line">		//因此也会调用realStartActivityLocked();</span><br><span class="line">		//如果resume 一个已经start过的activity（比如按back键回到前一个activity），</span><br><span class="line">		//那么ActivityRecord.app就不为null;此时resume一个已经start过的activity;  </span><br><span class="line">		</span><br><span class="line">           if (DEBUG_SWITCH) Slog.v(TAG, &quot;Resume running: &quot; + next);</span><br><span class="line"></span><br><span class="line">           // This activity is now becoming visible.</span><br><span class="line">           //⑧看到了没，next Activity是在resume时设置窗口可见的。  </span><br><span class="line">           mWindowManager.setAppVisibility(next.appToken, true);</span><br><span class="line"></span><br><span class="line">           // schedule launch ticks to collect information about slow apps.</span><br><span class="line">           next.startLaunchTickingLocked();</span><br><span class="line"></span><br><span class="line">           ActivityRecord lastResumedActivity =</span><br><span class="line">                   lastStack == null ? null :lastStack.mResumedActivity;</span><br><span class="line">           ActivityState lastState = next.state;</span><br><span class="line"></span><br><span class="line">           mService.updateCpuStats();</span><br><span class="line"></span><br><span class="line">           if (DEBUG_STATES) Slog.v(TAG, &quot;Moving to RESUMED: &quot; + next + &quot; (in existing)&quot;);</span><br><span class="line"></span><br><span class="line">		//⑧设置ActivityRecord.state=Resumed </span><br><span class="line">           next.state = ActivityState.RESUMED;</span><br><span class="line">           mResumedActivity = next;</span><br><span class="line">           next.task.touchActiveTime();</span><br><span class="line"></span><br><span class="line">		//⑧既然已经resume了，自然要把当前Task加入到RecentTask中去，这个后续重点研究下  </span><br><span class="line">           mService.addRecentTaskLocked(next.task);</span><br><span class="line"></span><br><span class="line">		//⑧activity已经resume了，那该activity所属的进程重量值就要改变嘛，</span><br><span class="line">		//这样就不能轻易杀掉用户正在使用的apk吧  </span><br><span class="line">           mService.updateLruProcessLocked(next.app, true, true);</span><br><span class="line">           updateLRUListLocked(next);</span><br><span class="line"></span><br><span class="line">           // Have the window manager re-evaluate the orientation of</span><br><span class="line">           // the screen based on the new activity order.</span><br><span class="line">           boolean notUpdated = true;</span><br><span class="line">           if (mStackSupervisor.isFrontStack(this)) &#123;</span><br><span class="line"></span><br><span class="line">			//⑧这个条件必然成立，从Activity所对应的窗口属性中提取出配置信息，</span><br><span class="line">			//比如屏幕转向等信息。为什么要这么做，因为当前要resume一个Activity，</span><br><span class="line">			//那么其他Activity必然需要跟随当前resume的Activity更新屏幕方向等。</span><br><span class="line">			//此时还必须冻结屏幕（FreezeScreen）。</span><br><span class="line">			//调用mService.updateConfigurationLocked()将屏幕方向信息更新到AMS中来。</span><br><span class="line">			//这个地方极有可能出横屏卡死的bug，后面再深入研究下  </span><br><span class="line">			</span><br><span class="line">               Configuration config = mWindowManager.updateOrientationFromAppTokens(</span><br><span class="line">                       mService.mConfiguration,</span><br><span class="line">                       next.mayFreezeScreenLocked(next.app) ? next.appToken : null);</span><br><span class="line">               if (config != null) &#123;</span><br><span class="line">                   next.frozenBeforeDestroy = true;</span><br><span class="line">               &#125;</span><br><span class="line">               notUpdated = !mService.updateConfigurationLocked(config, next, false, false);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">			//此处会回调 StackSupervisor 的startSpecificActivityLocked，此函数会回调另外一个函数</span><br><span class="line">			//可以理解为 在此函数中会初始化一些 activity的 info信息，比如 Application的一些信息</span><br><span class="line">               mStackSupervisor.startSpecificActivityLocked(next, true, false);</span><br><span class="line">			</span><br><span class="line">               if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">          </span><br><span class="line">           try &#123;</span><br><span class="line">               next.visible = true;</span><br><span class="line">               completeResumeLocked(next);</span><br><span class="line">           &#125; </span><br><span class="line">           </span><br><span class="line">           ...</span><br><span class="line"></span><br><span class="line">       &#125; else &#123;</span><br><span class="line">          </span><br><span class="line"></span><br><span class="line">		//⑨resume一个新的activity（还未跟进程关联的Activity），</span><br><span class="line">		//进程可能还没起来。调用startSpecificActivityLocked()，</span><br><span class="line">		//在这个函数中会寻找目标进程，如果目标进程存在，</span><br><span class="line">		//那么就直接调用realStartActivityLocked()，如果目标进程不存在那么就先startProcess;  </span><br><span class="line">           if (!next.hasBeenLaunched) &#123;</span><br><span class="line">               next.hasBeenLaunched = true;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">              ...</span><br><span class="line">               &#125;</span><br><span class="line">             </span><br><span class="line">          ...</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> 在这段相当长的代码中，我们要关注的函数有两个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">startPausingLocked(userLeaving, false);</span><br><span class="line"></span><br><span class="line">mStackSupervisor.startSpecificActivityLocked(next, true, false);</span><br></pre></td></tr></table></figure></p>
<p> 为什么呢？ 我们看下源代码就知道了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">final void startPausingLocked(boolean userLeaving, boolean uiSleeping) &#123;</span><br><span class="line">      if (mPausingActivity != null) &#123;</span><br><span class="line">	//如果要pause一个Activity时，已经有一个Activity在pause还未完成</span><br><span class="line">	//(pause完成的话mPausingActivity 为null），那么抛出一个异常。  </span><br><span class="line">         ...</span><br><span class="line">      &#125;</span><br><span class="line">      ActivityRecord prev = mResumedActivity;</span><br><span class="line"></span><br><span class="line"> //mResumedActivity中保存的是当前resume的Activity，</span><br><span class="line"> ///pause的对象肯定是当前的resume的Activity，</span><br><span class="line"> //如果当前没有resume对象，这种情况也就是系统启动第一个Activity才有的情况，</span><br><span class="line"> //此时就直接resume Activity栈中的顶层Activity。  </span><br><span class="line">      if (prev == null) &#123;</span><br><span class="line">          Slog.e(TAG, &quot;Trying to pause when nothing is resumed&quot;,</span><br><span class="line">                  new RuntimeException(&quot;here&quot;).fillInStackTrace());</span><br><span class="line">          mStackSupervisor.resumeTopActivitiesLocked();</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      if (DEBUG_STATES) Slog.v(TAG, &quot;Moving to PAUSING: &quot; + prev);</span><br><span class="line">      else if (DEBUG_PAUSE) Slog.v(TAG, &quot;Start pausing: &quot; + prev);</span><br><span class="line"></span><br><span class="line">//当前resume的Activity要被pause掉了，</span><br><span class="line">//那么mResumedActivity必然要重置为null了，</span><br><span class="line">//同时mPausingActivity指向当前resumed的Activity。</span><br><span class="line">      mResumedActivity = null;</span><br><span class="line">      mPausingActivity = prev;</span><br><span class="line">      mLastPausedActivity = prev;</span><br><span class="line">      mLastNoHistoryActivity = (prev.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NO_HISTORY) != 0</span><br><span class="line">              || (prev.info.flags &amp; ActivityInfo.FLAG_NO_HISTORY) != 0 ? prev : null;</span><br><span class="line"></span><br><span class="line">////要pause的ActivityRecord.state状态设置为PAUSING  </span><br><span class="line">      prev.state = ActivityState.PAUSING;</span><br><span class="line"></span><br><span class="line">      prev.task.touchActiveTime();</span><br><span class="line">      clearLaunchTime(prev);</span><br><span class="line">      prev.updateThumbnail(screenshotActivities(prev), null);</span><br><span class="line"></span><br><span class="line">      stopFullyDrawnTraceIfNeeded();</span><br><span class="line"></span><br><span class="line">      mService.updateCpuStats();</span><br><span class="line"></span><br><span class="line">      if (prev.app != null &amp;&amp; prev.app.thread != null) &#123;</span><br><span class="line">          if (DEBUG_PAUSE) Slog.v(TAG, &quot;Enqueueing pending pause: &quot; + prev);</span><br><span class="line">          try &#123;</span><br><span class="line">              EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY,</span><br><span class="line">                      prev.userId, System.identityHashCode(prev),</span><br><span class="line">                      prev.shortComponentName);</span><br><span class="line">              mService.updateUsageStats(prev, false);</span><br><span class="line"></span><br><span class="line">		//回调上层应用ActivityThread的schedulePauseActivity()函数，做一些应用层的处理工作。  </span><br><span class="line">              prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,</span><br><span class="line">                      userLeaving, prev.configChangeFlags);</span><br><span class="line">          &#125; catch (Exception e) &#123;</span><br><span class="line">              Slog.w(TAG, &quot;Exception thrown during pause&quot;, e);</span><br><span class="line">              mPausingActivity = null;</span><br><span class="line">              mLastPausedActivity = null;</span><br><span class="line">              mLastNoHistoryActivity = null;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          mPausingActivity = null;</span><br><span class="line">          mLastPausedActivity = null;</span><br><span class="line">          mLastNoHistoryActivity = null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!mService.isSleepingOrShuttingDown()) &#123;</span><br><span class="line"></span><br><span class="line">	//⑦获取一个唤醒锁，防止系统睡眠，获取唤醒锁时要注意释放，</span><br><span class="line">	//看解释知道在Activity完全起来后必然会释放这个锁，</span><br><span class="line">	//但是如果出现异常呢？Google代码写的很健壮，在获取一个唤醒锁时，</span><br><span class="line">	//同时也会post一个超时消息，如果超时了还没释放这个锁，</span><br><span class="line">	//那么就在这个超时消息处理中释放唤醒锁。  </span><br><span class="line">          mStackSupervisor.acquireLaunchWakelock();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (mPausingActivity != null) &#123;</span><br><span class="line">         </span><br><span class="line">          if (!uiSleeping) &#123;</span><br><span class="line"></span><br><span class="line">		//⑧pause一个Activity时，需要关闭这个Activity的输入事件通道，</span><br><span class="line">		//关闭一个输入通道只需将与该Activity对应的WindowToken.paused设为true,</span><br><span class="line">		//然后调用updateInputWindowsLw(true)将窗口状态更新到InputDispatcher中，</span><br><span class="line">		//InputDispatcher分发消息时是不会分发给paused状态窗口的，以此达到关闭输入通道效果。  </span><br><span class="line">              prev.pauseKeyDispatchingLocked();</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              if (DEBUG_PAUSE) Slog.v(TAG, &quot;Key dispatch not paused for screen off&quot;);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">	////⑨post一个PAUSE_TIMEOUT_MSG消息，为什么要post这么个消息，</span><br><span class="line">	//是因为如果无法完成paused前一个Activity，</span><br><span class="line">	//那么就无法start下一个Activity，这个超时消息是防止异常导致无法及时start下一个Activity，</span><br><span class="line">	//在超时消息处理函数中肯定有start next Activity的逻辑。  </span><br><span class="line">          Message msg = mHandler.obtainMessage(PAUSE_TIMEOUT_MSG);</span><br><span class="line">          msg.obj = prev;</span><br><span class="line">          prev.pauseTime = SystemClock.uptimeMillis();</span><br><span class="line">          mHandler.sendMessageDelayed(msg, PAUSE_TIMEOUT);</span><br><span class="line">          if (DEBUG_PAUSE) Slog.v(TAG, &quot;Waiting for pause to complete...&quot;);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         </span><br><span class="line">          if (DEBUG_PAUSE) Slog.v(TAG, &quot;Activity not running, resuming next.&quot;);</span><br><span class="line">          mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p> 看完这段代码应该就清楚了，这个函数是用来将我们的源 Activity 进行 pause的，具体实现是在 51 行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags);</span><br></pre></td></tr></table></figure></p>
<p>  pre.app 获取到是 ProcessRecord 类，该类的 thread 变量是一个 IApplicationThread 类型的数据，但是呢，这个IApplicationThread 是一个接口，所以，最核心的问题就是这个接口的实现是在哪里？答案是在 ActivityThread 里面，在 ActivtyThread 里面有一个内部类：ApplicationThread，这个类继承了ApplicationThreadNative 类，并继承了父类实现的接口：IApplicationThread，所以，prev.app.thread.schedulePauseActivity()方法其实就是ApplicationThread 的 schedulePauseActivity方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges) &#123;</span><br><span class="line">   queueOrSendMessage(finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY, token,(userLeaving ? 1 : 0), configChanges);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p> 方法还是很简单的，就是往一个 H 的线程里面传输一个 message ，那么这个 H 有时在哪实现的呢, 同样是在 ActivityThread里面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private class H extends Handler &#123;</span><br><span class="line">   public void handleMessage(Message msg) &#123;</span><br><span class="line">    case PAUSE_ACTIVITY:</span><br><span class="line">                   Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityPause&quot;);</span><br><span class="line">                   handlePauseActivity((IBinder)msg.obj, false, msg.arg1 != 0, msg.arg2);</span><br><span class="line">                   maybeSnapshot();</span><br><span class="line">                   Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                   break;</span><br><span class="line">                   &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<p> 里面核心的 handlePauseActivity 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void handlePauseActivity(IBinder token, boolean finished,</span><br><span class="line">           boolean userLeaving, int configChanges) &#123;</span><br><span class="line"></span><br><span class="line">    // 执行 pause 的地方</span><br><span class="line">       ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">	</span><br><span class="line">       if (r != null) &#123;</span><br><span class="line">          </span><br><span class="line">           if (userLeaving) &#123;</span><br><span class="line">               performUserLeavingActivity(r);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line"></span><br><span class="line">		//通过mInstrumentation 来回调 pause 操作</span><br><span class="line">           performPauseActivity(token, finished, r.isPreHoneycomb());</span><br><span class="line"></span><br><span class="line">           if (r.isPreHoneycomb()) &#123;</span><br><span class="line">               QueuedWork.waitToFinish();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           try &#123;</span><br><span class="line">               ActivityManagerNative.getDefault().activityPaused(token);</span><br><span class="line">           &#125; catch (RemoteException ex) &#123;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> 同样该函数会调用 performPauseActivity 第16行的 performPauseActivity()来执行下一步操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">final Bundle performPauseActivity(ActivityClientRecord r, boolean finished,boolean saveState) &#123;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">//此处为核心代码，回调的 activity的 pause 函数会在此执行</span><br><span class="line">           mInstrumentation.callActivityOnPause(r.activity);</span><br><span class="line">           </span><br><span class="line">   ...</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public class Instrumentation &#123;</span><br><span class="line">   public void callActivityOnPause(Activity activity) &#123;</span><br><span class="line"></span><br><span class="line">    //会回调activity的pause 操作</span><br><span class="line">       activity.performPause();</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public class Activity extends ContextThemeWrapper</span><br><span class="line">       implements LayoutInflater.Factory2,</span><br><span class="line">       Window.Callback, KeyEvent.Callback,</span><br><span class="line">       OnCreateContextMenuListener, ComponentCallbacks2 &#123;</span><br><span class="line">       </span><br><span class="line">    final void performPause() &#123;</span><br><span class="line">       mDoReportFullyDrawn = false;</span><br><span class="line">       mFragments.dispatchPause();</span><br><span class="line">       mCalled = false;</span><br><span class="line"></span><br><span class="line">	//回调函数，执行onPause()</span><br><span class="line">       onPause();</span><br><span class="line">	</span><br><span class="line">       mResumed = false;</span><br><span class="line">       if (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion</span><br><span class="line">               &gt;= android.os.Build.VERSION_CODES.GINGERBREAD) &#123;</span><br><span class="line">           throw new SuperNotCalledException(</span><br><span class="line">                   &quot;Activity &quot; + mComponent.toShortString() +</span><br><span class="line">                   &quot; did not call through to super.onPause()&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       mResumed = false;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> 至此，我们终于看到了一个熟悉的函数 onPause() 到这里，一个activity的 pause就执行完成了，我们回忆一下，我们目前已经将我们的源 activity 执行到onPause() 的销毁程序了，那么我就要开始执行目标activity的生成操作了,再把目光放到ActivityStack 代码上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mStackSupervisor.startSpecificActivityLocked(next, true, false);</span><br></pre></td></tr></table></figure></p>
<p> 在ResumeTopActivityLocked 中我们会通过这个函数进入activity的创建过程中，此处会回调 StackSupervisor 的startSpecificActivityLocked，此函数会回调另外一个函数，可以理解为 在此函数中会初始化一些 activity的 info信息，比如 Application的一些信息：具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  void startSpecificActivityLocked(ActivityRecord r,</span><br><span class="line">            boolean andResume, boolean checkConfig) &#123;</span><br><span class="line">       </span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">		//创建目标 Activity 的 ActivityRecord 的信息</span><br><span class="line">         realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    final boolean realStartActivityLocked(ActivityRecord r,</span><br><span class="line">ProcessRecord app, boolean andResume, boolean checkConfig)</span><br><span class="line"> throws RemoteException &#123;</span><br><span class="line"> </span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            //开始加载我们要显示的activity， app.thread 是ApplicationThread，</span><br><span class="line">			//是一个 ActivityThrad 的内部类。</span><br><span class="line">            app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,System.identityHashCode(r), r.info,new Configuration(mService.mConfiguration), r.compat,app.repProcState, r.icicle, results, newIntents, !andResume,mService.isNextTransitionForward(), profileFile, profileFd,profileAutoStop);</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p> 看到这，我们会有一种很熟悉的感觉，我们开始和pause的流程一样，调用了 applicationThread的函数，同样追踪一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">   public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,</span><br><span class="line">                ActivityInfo info, Configuration curConfig, CompatibilityInfo compatInfo,</span><br><span class="line">                int procState, Bundle state, List&lt;ResultInfo&gt; pendingResults,</span><br><span class="line">                List&lt;Intent&gt; pendingNewIntents, boolean notResumed, boolean isForward,</span><br><span class="line">                String profileName, ParcelFileDescriptor profileFd, boolean autoStopProfiler) &#123;</span><br><span class="line"></span><br><span class="line">            updateProcessState(procState, false);</span><br><span class="line"></span><br><span class="line">            ActivityClientRecord r = new ActivityClientRecord();</span><br><span class="line"></span><br><span class="line">            r.token = token;</span><br><span class="line">            r.ident = ident;</span><br><span class="line">            r.intent = intent;</span><br><span class="line">            r.activityInfo = info;</span><br><span class="line">            r.compatInfo = compatInfo;</span><br><span class="line">            r.state = state;</span><br><span class="line"></span><br><span class="line">            r.pendingResults = pendingResults;</span><br><span class="line">            r.pendingIntents = pendingNewIntents;</span><br><span class="line"></span><br><span class="line">            r.startsNotResumed = notResumed;</span><br><span class="line">            r.isForward = isForward;</span><br><span class="line"></span><br><span class="line">            r.profileFile = profileName;</span><br><span class="line">            r.profileFd = profileFd;</span><br><span class="line">            r.autoStopProfiler = autoStopProfiler;</span><br><span class="line"></span><br><span class="line">            updatePendingConfiguration(curConfig);</span><br><span class="line"></span><br><span class="line">            queueOrSendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private class H extends Handler &#123;</span><br><span class="line"> </span><br><span class="line">  public void handleMessage(Message msg) &#123;</span><br><span class="line">            if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));</span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                case LAUNCH_ACTIVITY: &#123;</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);</span><br><span class="line">                    ActivityClientRecord r = (ActivityClientRecord)msg.obj;</span><br><span class="line"></span><br><span class="line">                    r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                            r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">                    handleLaunchActivity(r, null);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                &#125; break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">    </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">         //如果此时 activity 执行finish() 操作，将会执行 finish操作，而不会执行 resume 操作。</span><br><span class="line">         if (a != null) &#123;</span><br><span class="line">          handleResumeActivity(r.token, false, r.isForward,</span><br><span class="line">                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">         ActivityManagerNative.getDefault()</span><br><span class="line">                    .finishActivity(r.token, Activity.RESULT_CANCELED, null);</span><br><span class="line">         &#125;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        activity.attach(appContext, this, getInstrumentation(), r.token,r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">r.embeddedID, r.lastNonConfigurationInstances, config);</span><br><span class="line"></span><br><span class="line">        mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">                if (!activity.mCalled) &#123;</span><br><span class="line">                    throw new SuperNotCalledException(</span><br><span class="line">                        &quot;Activity &quot; + r.intent.getComponent().toShortString() +</span><br><span class="line">                        &quot; did not call through to super.onCreate()&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                r.activity = activity;</span><br><span class="line">                r.stopped = true;</span><br><span class="line">                if (!r.activity.mFinished) &#123;</span><br><span class="line">                    activity.performStart();</span><br><span class="line">                    r.stopped = false;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!r.activity.mFinished) &#123;</span><br><span class="line">                    if (r.state != null) &#123;</span><br><span class="line">                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!r.activity.mFinished) &#123;</span><br><span class="line">                    activity.mCalled = false;</span><br><span class="line">                    mInstrumentation.callActivityOnPostCreate(activity, r.state);</span><br><span class="line">                    if (!activity.mCalled) &#123;</span><br><span class="line">                        throw new SuperNotCalledException(</span><br><span class="line">                            &quot;Activity &quot; + r.intent.getComponent().toShortString() +</span><br><span class="line">                            &quot; did not call through to super.onPostCreate()&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           </span><br><span class="line">           </span><br><span class="line">public class Instrumentation &#123;</span><br><span class="line"></span><br><span class="line">     public void callActivityOnCreate(Activity activity, Bundle icicle) &#123;</span><br><span class="line">        if (mWaitingActivities != null) &#123;</span><br><span class="line">            synchronized (mSync) &#123;</span><br><span class="line">                final int N = mWaitingActivities.size();</span><br><span class="line">                for (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">                    final ActivityWaiter aw = mWaitingActivities.get(i);</span><br><span class="line">                    final Intent intent = aw.intent;</span><br><span class="line">                    if (intent.filterEquals(activity.getIntent())) &#123;</span><br><span class="line">                        aw.activity = activity;</span><br><span class="line">                        mMessageQueue.addIdleHandler(new ActivityGoing(aw));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        activity.performCreate(icicle);</span><br><span class="line">        </span><br><span class="line">        if (mActivityMonitors != null) &#123;</span><br><span class="line">            synchronized (mSync) &#123;</span><br><span class="line">                final int N = mActivityMonitors.size();</span><br><span class="line">                for (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">                    final ActivityMonitor am = mActivityMonitors.get(i);</span><br><span class="line">                    am.match(activity, activity, activity.getIntent());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">Class Activity &#123;</span><br><span class="line">     final void performCreate(Bundle icicle) &#123;</span><br><span class="line">        onCreate(icicle);</span><br><span class="line">        mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(</span><br><span class="line">                com.android.internal.R.styleable.Window_windowNoDisplay, false);</span><br><span class="line">        mFragments.dispatchActivityCreated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 至此，我们可以看到我们流程已经进行到了 onCreat()函数，说明我们得流程已经完全走下来了。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="/2016/04/16/activity-的启动/#comment" class="comment-link">评论</a>
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/blog/">blog</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/android-activity/">android activity</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-activity-的启动" data-title="activity 的启动" data-url="http://yoursite.com/2016/04/16/activity-的启动/"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
  var duoshuoQuery = {short_name:'huronghui'};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
       || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
  <!-- 多说公共JS代码 end -->

</section>


</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/blog/">blog</a><small>5</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2016/04/20/Window-View-关系梳理/">Window View 关系梳理</a>
      </li>
    
      <li>
        <a href="/2016/04/18/activity-事件分发过程/">activity 事件分发过程</a>
      </li>
    
      <li>
        <a href="/2016/04/16/activity-的启动/">activity 的启动</a>
      </li>
    
      <li>
        <a href="/2016/04/14/setContentView-解析/">setContentView 解析</a>
      </li>
    
      <li>
        <a href="/2016/04/14/ViewGroup-的事件传递/">ViewGroup  的事件传递</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/android-View/">android View</a><small>1</small></li>
  
    <li><a href="/tags/android-activity/">android activity</a><small>1</small></li>
  
    <li><a href="/tags/android-window/">android window</a><small>1</small></li>
  
    <li><a href="/tags/android-事件分发/">android 事件分发</a><small>3</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/android-View/" style="font-size: 10px;">android View</a> <a href="/tags/android-activity/" style="font-size: 10px;">android activity</a> <a href="/tags/android-window/" style="font-size: 10px;">android window</a> <a href="/tags/android-事件分发/" style="font-size: 20px;">android 事件分发</a>
  </div>
</div>


  <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=5&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=2203673484&verifier=607c53d8&dpc=1"></iframe>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2016 huronghui
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id='bg'></div>
</body>
</html>