<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  
  <title>Service 分析 | 霜白</title>
  <meta name="author" content="huronghui" />

  
  <meta name="description" content="android" />
  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <meta property="og:title" content="Service 分析" />
  <meta property="og:site_name" content="霜白" />

  
  

  
    <meta property="og:image" content="undefined" />
  

  
  <link href="/css/images/favicon.ico" rel="icon" />
  

  <link rel="alternate" href="/atom.xml" title="霜白" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">霜白</a></h1>
  <h2><a href="/">栀年年年</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-21T12:51:20.000Z"><a href="/2016/04/21/Service-分析/">2016-04-21</a></time>
      
      
  
    <h1 class="title">Service 分析</h1>
  

    </header>
    <div class="entry">
      
        <p>关于 Service 的启动我们主要有两种方式，主要有两种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(TestServiceAactivity.this, TestThirdService.class);</span><br><span class="line">startService(intent);</span><br><span class="line">  </span><br><span class="line">Intent intent = new Intent(TestServiceAactivity.this, TestThirdService.class);</span><br><span class="line">bindService(intent, serviceConnection, BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure></p>
<p> 一种是 startService()， 一种是 bindService() 这两种代表了两种不同的 Service 的启动方式，两个有什么区别呢？</p>
<ol>
<li>第一种方式是 在activity 中启动了service，启动完成以后，就不会有任何方式来接触到 service 的运行，只能在 activity 的onDestory 中执行 stopService()</li>
<li>第二种方式是我们在 Service 中建立一个 Binder，通过 bindService 来建立 service 和 activity 之前的联系，使得 activity 可以获取 service 中运行的函数。</li>
</ol>
<a id="more"></a>
<p>###BindService<br>以 BindService 为例，我们看一下整个的流程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class TestOneService extends Service&#123;</span><br><span class="line"></span><br><span class="line">    private static String TAG = &quot;TestOneService&quot;;</span><br><span class="line"></span><br><span class="line">    private ClassBinder classBinder = new ClassBinder();</span><br><span class="line"></span><br><span class="line">    class ClassBinder extends Binder &#123;</span><br><span class="line"></span><br><span class="line">        public void startBinder() &#123;</span><br><span class="line">            Log.i(TAG, &quot;StartSerivce&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void stopBinder() &#123;</span><br><span class="line">            Log.i(TAG, &quot;StopBinder&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return classBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestServiceAactivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private TestOneService.ClassBinder classBinder;</span><br><span class="line">    private ServiceConnection serviceConnection = new ServiceConnection() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            classBinder = (TestOneService.ClassBinder)service;</span><br><span class="line">            classBinder.startBinder();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">     @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.testservice);</span><br><span class="line">        Intent intent = new Intent(TestServiceAactivity.this, TestThirdService.class);</span><br><span class="line">        bindService(intent, serviceConnection, BIND_AUTO_CREATE);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出：</p>
<ol>
<li>我们新建了一个ClassBinder 类，继承了 Binder，然后在其内部提供了两个模拟方法，</li>
<li>接着我们创建了一个 ClassBinder 类的实例，并且在 onBinder 中返货这个实例，至此， Service 中的工作就全部完成，</li>
<li>再看一下 activity 中的代码：我们创建了一个 ServiceConnection 的实例，并在里面重写了onServiceConnected()方法，这个方法分别会在活动和服务绑定以及解除绑定的时候调用，并在 onServiceConnected() 方法中，向下得到了 ClassBinder 的实例，有了这个实例，我们 activity 和 service 之间的关系就会变得非常紧密，即我们可以根据实际场景来调用 ClassBinder 中的任何的 public 的方法，也就是实现了指挥服务干什么，服务就会去干什么的功能。</li>
</ol>
<p>###前台服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> public class TestOneService extends Service&#123;</span><br><span class="line"></span><br><span class="line">    private static String TAG = &quot;TestOneService&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        PendingIntent pendingIntent3 = PendingIntent.getActivity(this, 0,</span><br><span class="line">                new Intent(this, TestServiceAactivity.class), 0);</span><br><span class="line">        Notification notify3 = new Notification.Builder(this)</span><br><span class="line">                .setSmallIcon(R.mipmap.ic_launcher)</span><br><span class="line">                .setTicker(&quot;TickerText:&quot; + &quot;您有新短消息，请注意查收！&quot;)</span><br><span class="line">                .setContentTitle(&quot;Notification Title&quot;)</span><br><span class="line">                .setContentText(&quot;This is the notification message&quot;)</span><br><span class="line">                .setContentIntent(pendingIntent3).setNumber(1).build(); // 需要注意build()是在API</span><br><span class="line">        // level16及之后增加的，API11可以使用getNotificatin()来替代</span><br><span class="line">        notify3.flags |= Notification.FLAG_AUTO_CANCEL; // FLAG_AUTO_CANCEL表明当通知被用户点击时，通知将被清除。</span><br><span class="line">        startForeground(1, notify3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 我们如果使用一些天气软件的话，会发现一个问题，在我们通知栏界面会长期停止一个通知栏，显示当前天气信息，这就是前台服务，即一个service 可以长期在前台显示，具体实现如上，调用的是一个 Notification 的通知类，和正常显示 Notification 不一样的是，显示是用 startForeground 函数，这个函数会让 service 变成一个前台服务，并且在系统的状态栏显示出来。</p>
<p>###后台执行定时任务<br>定时是一个程序执行心跳服务时涉及到的问题，常规的 android 定时任务实现一般是这两种：</p>
<ol>
<li>Java Api 中提供的 Timer 类</li>
<li>一个是使用 Android的 Alarm机制，</li>
</ol>
<p>这两种基本都可以实现相同的定时效果，但 Timer有一个明显的缺点，就是不适合哪些需要长期在后台运行的定时任务，如果手机进入睡眠状态，将导致 Timer 中的定时任务无法执行，Alarm 机制则不存在这种问题，毕竟这是android自己特有的机制，它具有唤醒 CPU 的功能，因此，在android中，如果需要实现定时任务，那么推荐使用 Alarm 机制。我们看一下具体实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> public class TestThirdService extends Service &#123;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line"></span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">        //定时任务的具体实现所在</span><br><span class="line">                Log.i(&quot;TestThirdService&quot;, &quot;thread id is that&quot; + Thread.currentThread().getId() + &quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        AlarmManager manager = (AlarmManager) getSystemService(ALARM_SERVICE);</span><br><span class="line">        int anHour = 60 * 1000;</span><br><span class="line">        long triggerAtTime = SystemClock.elapsedRealtime() + anHour;</span><br><span class="line">        Intent intent1 = new Intent(this, AlarmReceive.class);</span><br><span class="line">        PendingIntent pendingIntent = PendingIntent.getBroadcast(this, 0, intent1, 0);</span><br><span class="line">        manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pendingIntent);</span><br><span class="line">        return super.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AlarmReceive extends BroadcastReceiver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        Intent intent1 = new Intent(context, TestThirdService.class);</span><br><span class="line">        context.startService(intent1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如此，我们就实现了一个定时的任务，分析下代码：</p>
<ul>
<li>在 onStartCommand 中，我们定义了一个线程，在线程里面实现具体的操作</li>
<li>接着我们定义了一个 AlarmManager 类来管理定时任务，最关键的是 Alarmmanager 的set 方法：set(int type，long startTime，PendingIntent pi)；该方法用于设置一次性闹钟，第一个参数表示闹钟类型，第二个参数表示闹钟执行时间，第三个参数表示闹钟响应动作。</li>
<li>三个方法各个参数详悉：</li>
</ul>
<p>（1）int type： 闹钟的类型，常用的有5个值：AlarmManager.ELAPSED_REALTIME、 AlarmManager.ELAPSED_REALTIME_WAKEUP、AlarmManager.RTC、 AlarmManager.RTC_WAKEUP、AlarmManager.POWER_OFF_WAKEUP。</p>
<p>AlarmManager.ELAPSED_REALTIME表示闹钟在手机睡眠状态下不可用，该状态下闹钟使用相对时间（相对于系统启动开始），状态值为3；</p>
<p>AlarmManager.ELAPSED_REALTIME_WAKEUP表示闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟也使用相对时间，状态值为2；</p>
<p>AlarmManager.RTC表示闹钟在睡眠状态下不可用，该状态下闹钟使用绝对时间，即当前系统时间，状态值为1；</p>
<p>AlarmManager.RTC_WAKEUP表示闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟使用绝对时间，状态值为0；</p>
<p>AlarmManager.POWER_OFF_WAKEUP表示闹钟在手机关机状态下也能正常进行提示功能，所以是5个状态中用的最多的状态之一，该状态下闹钟也是用绝对时间，状态值为4；不过本状态好像受SDK版本影响，某些版本并不支持；</p>
<p>（2）long startTime： 闹钟的第一次执行时间，以毫秒为单位，可以自定义时间，不过一般使用当前时间。需要注意的是，本属性与第一个属性（type）密切相关，如果第一个参数对 应的闹钟使用的是相对时间（ELAPSED_REALTIME和ELAPSED_REALTIME_WAKEUP），那么本属性就得使用相对时间（相对于 系统启动时间来说），比如当前时间就表示为：SystemClock.elapsedRealtime()；如果第一个参数对应的闹钟使用的是绝对时间 （RTC、RTC_WAKEUP、POWER_OFF_WAKEUP），那么本属性就得使用绝对时间，比如当前时间就表示 为：System.currentTimeMillis()。</p>
<p>（3）long intervalTime：对于后两个方法来说，存在本属性，表示两次闹钟执行的间隔时间，也是以毫秒为单位。</p>
<p>（4）PendingIntent pi： 绑定了闹钟的执行动作，比如发送一个广播、给出提示等等。PendingIntent是Intent的封装类。需要注意的是，如果是通过启动服务来实现闹钟提 示的话，PendingIntent对象的获取就应该采用Pending.getService(Context c,int i,Intent intent,int j)方法；如果是通过广播来实现闹钟提示的话，PendingIntent对象的获取就应该采用 PendingIntent.getBroadcast(Context c,int i,Intent intent,int j)方法；如果是采用Activity的方式来实现闹钟提示的话，PendingIntent对象的获取就应该采用 PendingIntent.getActivity(Context c,int i,Intent intent,int j)方法。如果这三种方法错用了的话，虽然不会报错，但是看不到闹钟提示效果。（上文来源自：<a href="http://blog.csdn.net/wangxingwu_314/article/details/8060312）" target="_blank" rel="external">http://blog.csdn.net/wangxingwu_314/article/details/8060312）</a></p>
<p>在pendingIntent中我们是将启动一个 broadcast，在该broadcast中，我们有启动这个service，这样就实现了一个定时的循环任务。</p>
<p>至此，我们就结束了常用的service 的使用，下面我们就分析一下 service 的启动过程：</p>
<p>###service启动过程</p>
<p>###1.startService<br>  该函数是在activity中调用的，但我们却在activity中没有找到这个函数，说明该函数可能是在他的父类中实现的，但是我们在 activity 的父类 contextThemeWrap 中也没有发现这个函数，在接着往父类中寻找，在 ContextWrap 中我们终于找到了这个函数的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public ComponentName startService(Intent service) &#123;</span><br><span class="line">      return mBase.startService(service);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p> 发现在 startService 中并没有具体的实现，而是调用了 一个context 的startService 函数，然而，我们目前所在的类就是一个 context 类的子类 contextWrap，而且 context是一个抽象类，里面的函数都是没有具体实现的，那么这个 实现了 startService 方法的 context 类是哪一个类呢？答案是：contextImpl 类，从 ContextWrap 的实现方式来看，里面的大多数函数都是有 这个ContextImpl 实现的，在设计模式中，这是一个典型的桥接模式，那么接下来看 ContextImpl 的 startService 函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public ComponentName startService(Intent service) &#123;</span><br><span class="line">      warnIfCallingFromSystemProcess();</span><br><span class="line">      return startServiceCommon(service, mUser);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private ComponentName startServiceCommon(Intent service, UserHandle user) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          validateServiceIntent(service);</span><br><span class="line">          service.prepareToLeaveProcess();</span><br><span class="line"></span><br><span class="line">	//调用 AMS 来启动service，此处和activity 的启动大同小异</span><br><span class="line">          ComponentName cn = ActivityManagerNative.getDefault().startService(mMainThread.getApplicationThread(), service,service.resolveTypeIfNeeded(getContentResolver()), user.getIdentifier());</span><br><span class="line">          </span><br><span class="line">          ...</span><br><span class="line">          </span><br><span class="line">      &#125; catch (RemoteException e) &#123;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>startService 方法会调用 startServiceCommon 函数，而在startServiceCommon 函数中又会调用 ActivityManagerNative.getDefault().startService，ActivityManagerNative.getDefault() 这个方法我们应该很熟悉，如果看过之前的 activity 的启动流程分析的话，就应该知道，这个函数返回的是一个AMS(ActivityManagerService)，并且同activity 的启动方式一样，调用AMS来启动服务是一种远程进程调用，在 AMS 的startService 方法的实现如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public ComponentName startService(IApplicationThread caller, Intent service,String resolvedType, int userId) &#123;</span><br><span class="line">       enforceNotIsolatedCaller(&quot;startService&quot;);</span><br><span class="line">       </span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">    //加锁，线程安全</span><br><span class="line">       synchronized(this) &#123;</span><br><span class="line">           final int callingPid = Binder.getCallingPid();</span><br><span class="line">           final int callingUid = Binder.getCallingUid();</span><br><span class="line">           checkValidCaller(callingUid, userId);</span><br><span class="line">           final long origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">		//调用 mServices 来执行启动service 的后续工作</span><br><span class="line">           ComponentName res = mServices.startServiceLocked(caller, service,resolvedType, callingPid, callingUid, userId);</span><br><span class="line">           Binder.restoreCallingIdentity(origId);</span><br><span class="line">           return res;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> 在上面的代码中，我们可以看到， AMS 会调用 mServices 这个对象来实现后续的工作， mServices 是 ActiveServices ，这个类是辅助 AMS 来管理 service的管理类，包括 启动，绑定，停止等，进入 startServiceLocked 函数看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ComponentName startServiceLocked(IApplicationThread caller,</span><br><span class="line">Intent service, String resolvedType, int callingPid, int callingUid, int userId) &#123;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">	//和activity的启动方式一样，此处会生成一个 ServiceRecord 的实例</span><br><span class="line">	//此类描述了一个 Service 记录，该信息和activity 的启动一样，ServiceRecord</span><br><span class="line">	//也会一直贯穿整个 Service 的启动过程</span><br><span class="line">       ServiceRecord r = res.record;</span><br><span class="line">       NeededUriGrants neededGrants = mAm.checkGrantUriPermissionFromIntentLocked(</span><br><span class="line">               callingUid, r.packageName, service, service.getFlags(), null);</span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">       //后续会执行的函数，后续过程交给了这个函数</span><br><span class="line">       return startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> 在startServiceLocked 函数建了一个ServiceRecord 类，该类是描述的一个 Service 记录，并且该类贯穿了整个的 Service 的启动过程，最后调用了 startServiceInnerLocked 方法，实现如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ComponentName startServiceInnerLocked(ServiceMap smap, Intent service,ServiceRecord r, boolean callerFg, boolean addToStarting) &#123;</span><br><span class="line"></span><br><span class="line">       ProcessStats.ServiceState stracker = r.getTracker();</span><br><span class="line">       if (stracker != null) &#123;</span><br><span class="line">           stracker.setStarted(true, mAm.mProcessStats.getMemFactorLocked(), r.lastActivity);</span><br><span class="line">       &#125;</span><br><span class="line">       r.callStart = false;</span><br><span class="line">       synchronized (r.stats.getBatteryStats()) &#123;</span><br><span class="line">           r.stats.startRunningLocked();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">	//service 的启动过程的后续会交给下面的这个函数来继续执行</span><br><span class="line">       String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false);</span><br><span class="line">       if (error != null) &#123;</span><br><span class="line">           return new ComponentName(&quot;!!&quot;, error);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">       return r.name;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> startServiceInnerLocked 没有完成后续工作，而是又交给了bringUpServiceLocked方法来处理，在 bringUpServiceLocked 方法中又调用了 realStartServiceLocked 方法，从这个名字可以看出来 这可能就是 Service 的真正启动的地方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">private final void realStartServiceLocked(ServiceRecord r,</span><br><span class="line">          ProcessRecord app, boolean execInFg) throws RemoteException &#123;</span><br><span class="line">      if (DEBUG_MU)</span><br><span class="line">          Slog.v(TAG_MU, &quot;realStartServiceLocked, ServiceRecord.uid = &quot; + r.appInfo.uid</span><br><span class="line">                  + &quot;, ProcessRecord.uid = &quot; + app.uid);</span><br><span class="line">      r.app = app;</span><br><span class="line">      r.restartTime = r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">      app.services.add(r);</span><br><span class="line">      bumpServiceExecutingLocked(r, execInFg, &quot;create&quot;);</span><br><span class="line">      mAm.updateLruProcessLocked(app, true, false);</span><br><span class="line"></span><br><span class="line">      boolean created = false;</span><br><span class="line">      try &#123;</span><br><span class="line">          String nameTerm;</span><br><span class="line">          int lastPeriod = r.shortName.lastIndexOf(&apos;.&apos;);</span><br><span class="line">          nameTerm = lastPeriod &gt;= 0 ? r.shortName.substring(lastPeriod) : r.shortName;</span><br><span class="line">          EventLogTags.writeAmCreateService(</span><br><span class="line">                  r.userId, System.identityHashCode(r), nameTerm, r.app.uid, r.app.pid);</span><br><span class="line">          synchronized (r.stats.getBatteryStats()) &#123;</span><br><span class="line">              r.stats.startLaunchedLocked();</span><br><span class="line">          &#125;</span><br><span class="line">          mAm.ensurePackageDexOpt(r.serviceInfo.packageName);</span><br><span class="line">          app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line"></span><br><span class="line">	//和 activity 的启动过程大同小异，会调用 ApplicationThread 的scheduleCreateService</span><br><span class="line">	//函数来启动 service 的启动过程</span><br><span class="line">          app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                  mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                  app.repProcState);</span><br><span class="line">          r.postNotification();</span><br><span class="line">          created = true;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          if (!created) &#123;</span><br><span class="line">              app.services.remove(r);</span><br><span class="line">              scheduleServiceRestartLocked(r, false);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      //调用 Service 的 Binder 函数，所以service 是会先启用 oncreate 然后再启动 onbinder，</span><br><span class="line">      //最后才会调用 onstartCommand 函数</span><br><span class="line">      requestServiceBindingsLocked(r, execInFg);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">      if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) &#123;</span><br><span class="line">          r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),</span><br><span class="line">                  null, null));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">//在此处会调用 Service 的其他方法，比如 onStartCommand </span><br><span class="line">      sendServiceArgsLocked(r, execInFg, true);</span><br><span class="line"></span><br><span class="line">      if (r.delayed) &#123;</span><br><span class="line">          if (DEBUG_DELAYED_STATS) Slog.v(TAG, &quot;REM FR DELAY LIST (new proc): &quot; + r);</span><br><span class="line">          getServiceMap(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">          r.delayed = false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (r.delayedStop) &#123;</span><br><span class="line">          // Oh and hey we&apos;ve already been asked to stop!</span><br><span class="line">          r.delayedStop = false;</span><br><span class="line">          if (r.startRequested) &#123;</span><br><span class="line">              if (DEBUG_DELAYED_STATS) Slog.v(TAG, &quot;Applying delayed stop (from start): &quot; + r);</span><br><span class="line">              stopServiceLocked(r);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p> <strong>在 realStartServiceLocked 方法中：</strong></p>
<ul>
<li><strong>首先通过app.thread.scheduleCreateService 函数来创建 Service 对象，并且调用了 Service 的onCreate</strong></li>
<li><strong>接着会调用 sendServiceArgsLocked 来调用Service 的其他方法，比如 onStartCommand</strong></li>
<li><strong>这两个过程均是进程间通信，app.thread 是一个 IApplicationThread 类型，实际上他也是一个Binder 类型，具体的实现是 ApplicationThread，这个和 activity 是一样的，因此我们进入 ApplicationThread 的scheduleCreateService方法</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> public final void scheduleCreateService(IBinder token,</span><br><span class="line">ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123;</span><br><span class="line">           updateProcessState(processState, false);</span><br><span class="line">           CreateServiceData s = new CreateServiceData();</span><br><span class="line">           s.token = token;</span><br><span class="line">           s.info = info;</span><br><span class="line">           s.compatInfo = compatInfo;</span><br><span class="line"></span><br><span class="line">           queueOrSendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p> 这个过程和 activity 的启动过程很相似，都是通过给 Handle H 发消息完成的，在 H 中通过handleCreateService 来继续完成 Service 的最终启动，handleCreateService 的源码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">private void handleCreateService(CreateServiceData data) &#123;</span><br><span class="line">       // If we are getting ready to gc after going to the background, well</span><br><span class="line">       // we are back active so skip it.</span><br><span class="line">       unscheduleGcIdler();</span><br><span class="line"></span><br><span class="line">       LoadedApk packageInfo = getPackageInfoNoCheck(</span><br><span class="line">               data.info.applicationInfo, data.compatInfo);</span><br><span class="line">       Service service = null;</span><br><span class="line">       try &#123;</span><br><span class="line">           java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line"></span><br><span class="line">		//新建了一个 Service 的实例</span><br><span class="line">           service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           if (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">               throw new RuntimeException(</span><br><span class="line">                   &quot;Unable to instantiate service &quot; + data.info.name</span><br><span class="line">                   + &quot;: &quot; + e.toString(), e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name);</span><br><span class="line"></span><br><span class="line">           //创建了 ContextImpl 对象并通过Service 的attach 方法建立两者之间的关系</span><br><span class="line">           ContextImpl context = new ContextImpl();</span><br><span class="line">           context.init(packageInfo, null, this);</span><br><span class="line"></span><br><span class="line">		//创建了 Application对象并调用了其 oncreate，并且这个创建工程只会有一次</span><br><span class="line">           Application app = packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">           context.setOuterContext(service);</span><br><span class="line"></span><br><span class="line">		//类似于 Activity 的attach 方法，调用了 service 的attach 方法</span><br><span class="line">           service.attach(context, this, data.info.name, data.token, app,</span><br><span class="line">                   ActivityManagerNative.getDefault());</span><br><span class="line"></span><br><span class="line">		//调用了 Service 的onCreate()方法</span><br><span class="line">           service.onCreate();</span><br><span class="line">           mServices.put(data.token, service);</span><br><span class="line">           try &#123;</span><br><span class="line">               ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                       data.token, 0, 0, 0);</span><br><span class="line">           &#125; catch (RemoteException e) &#123;</span><br><span class="line">               // nothing to do.</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           if (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">               throw new RuntimeException(</span><br><span class="line">                   &quot;Unable to create service &quot; + data.info.name</span><br><span class="line">                   + &quot;: &quot; + e.toString(), e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> handleCreateService 主要实现的是如下几件事情：</p>
<ul>
<li>首先创建了一个Service 的实例</li>
<li>创建了一个 Application 对象，并调用其 onCreate 函数，当然创建过程只会有一次</li>
<li>创建了一个 ContextImpl 对象，并且通过attach方法进行绑定</li>
<li>会调用 Service 的oncrate 方法并将 Service 对象存储到 ActivityThread 中的而一个列表中。</li>
</ul>
<p>在此处，当Service 的onCreate 方法启动后，说明 Service 已经运行起来了，这时候，我们回到 ActiveServices 中，在执行完scheduleCreateService 函数，接着就会执行 sendServiceArgsLocked 函数，调用onStartCommand方法，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private final void sendServiceArgsLocked(ServiceRecord r, boolean execInFg,</span><br><span class="line">          boolean oomAdjusted) &#123;</span><br><span class="line">      final int N = r.pendingStarts.size();</span><br><span class="line">      if (N == 0) &#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      while (r.pendingStarts.size() &gt; 0) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              ServiceRecord.StartItem si = r.pendingStarts.remove(0);</span><br><span class="line">              if (DEBUG_SERVICE) Slog.v(TAG, &quot;Sending arguments to: &quot;</span><br><span class="line">                      + r + &quot; &quot; + r.intent + &quot; args=&quot; + si.intent);</span><br><span class="line">              if (si.intent == null &amp;&amp; N &gt; 1) &#123;</span><br><span class="line">                  continue;</span><br><span class="line">              &#125;</span><br><span class="line">              si.deliveredTime = SystemClock.uptimeMillis();</span><br><span class="line">              r.deliveredStarts.add(si);</span><br><span class="line">              si.deliveryCount++;</span><br><span class="line">              if (si.neededGrants != null) &#123;</span><br><span class="line">                  mAm.grantUriPermissionUncheckedFromIntentLocked(si.neededGrants,</span><br><span class="line">                          si.getUriPermissionsLocked());</span><br><span class="line">              &#125;</span><br><span class="line">              bumpServiceExecutingLocked(r, execInFg, &quot;start&quot;);</span><br><span class="line">              if (!oomAdjusted) &#123;</span><br><span class="line">                  oomAdjusted = true;</span><br><span class="line">                  mAm.updateOomAdjLocked(r.app);</span><br><span class="line">              &#125;</span><br><span class="line">              int flags = 0;</span><br><span class="line">              if (si.deliveryCount &gt; 1) &#123;</span><br><span class="line">                  flags |= Service.START_FLAG_RETRY;</span><br><span class="line">              &#125;</span><br><span class="line">              if (si.doneExecutingCount &gt; 0) &#123;</span><br><span class="line">                  flags |= Service.START_FLAG_REDELIVERY;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">		//同样是调用了 ApplicationThread 的类</span><br><span class="line">              r.app.thread.scheduleServiceArgs(r, si.taskRemoved, si.id, flags, si.intent);</span><br><span class="line">          &#125; </span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p> 和上面的启动一样，都是调用 ApplicationThread 来继续流程，看ApplicationThread 的scheduleServiceArgs函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public final void scheduleServiceArgs(IBinder token, boolean taskRemoved, int startId,</span><br><span class="line">        int flags ,Intent args) &#123;</span><br><span class="line">        ServiceArgsData s = new ServiceArgsData();</span><br><span class="line">        s.token = token;</span><br><span class="line">        s.taskRemoved = taskRemoved;</span><br><span class="line">        s.startId = startId;</span><br><span class="line">        s.flags = flags;</span><br><span class="line">        s.args = args;</span><br><span class="line"></span><br><span class="line">        queueOrSendMessage(H.SERVICE_ARGS, s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">private void handleServiceArgs(ServiceArgsData data) &#123;</span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    if (s != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (data.args != null) &#123;</span><br><span class="line">                data.args.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            &#125;</span><br><span class="line">            int res;</span><br><span class="line">            if (!data.taskRemoved) &#123;</span><br><span class="line"></span><br><span class="line">	//从此处可以看出调用了 onStartCommand 函数</span><br><span class="line">                res = s.onStartCommand(data.args, data.flags, data.startId);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                s.onTaskRemoved(data.args);</span><br><span class="line">                res = Service.START_TASK_REMOVED_COMPLETE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 可以看到 Handler H 会调用 handleServiceArgs来继续流程，并在这个函数中，调用了Service 的onStartCommand 函数，至此，Service 的startService 流程就结束了</p>
<p>###BindService<br>和Service 的启动流程一样，BinderService 的绑定流程也是用 ContextImpl 中实现的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public boolean bindService(Intent service, ServiceConnection conn,int flags) &#123;</span><br><span class="line">        warnIfCallingFromSystemProcess();</span><br><span class="line">        return bindServiceCommon(service, conn, flags, Process.myUserHandle());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags,</span><br><span class="line">            UserHandle user) &#123;</span><br><span class="line">        IServiceConnection sd;</span><br><span class="line">        if (conn == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;connection is null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (mPackageInfo != null) &#123;</span><br><span class="line"></span><br><span class="line">			//将客户端的 ServiceConnext 对象转换为 ServiceDispatcher.InnerConnection 对象</span><br><span class="line">			//此处不能直接使用 ServiceConnection 对象，这是因为服务的绑定有可能是跨进程的</span><br><span class="line">			//因此，ServiceConnection 对象必须借助 Binder 对象才能让远程远程服务器回调自己的方法</span><br><span class="line">            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(),</span><br><span class="line">                    mMainThread.getHandler(), flags);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Not supported in system context&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        validateServiceIntent(service);</span><br><span class="line">        try &#123;</span><br><span class="line">            IBinder token = getActivityToken();</span><br><span class="line">            if (token == null &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == 0 &amp;&amp; mPackageInfo != null</span><br><span class="line">                    &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion</span><br><span class="line">                    &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">                flags |= BIND_WAIVE_PRIORITY;</span><br><span class="line">            &#125;</span><br><span class="line">            service.prepareToLeaveProcess();</span><br><span class="line"></span><br><span class="line">			//ApplicationThread 调用的 bindService 函数</span><br><span class="line">            int res = ActivityManagerNative.getDefault().bindService(</span><br><span class="line">                mMainThread.getApplicationThread(), getActivityToken(),</span><br><span class="line">                service, service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">                sd, flags, user.getIdentifier());</span><br><span class="line">            if (res &lt; 0) &#123;</span><br><span class="line">                throw new SecurityException(</span><br><span class="line">                        &quot;Not allowed to bind to service &quot; + service);</span><br><span class="line">            &#125;</span><br><span class="line">            return res != 0;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p> 因为服务的绑定可能是会跨进程的额，所以我们不能直接只用 ServiceConnection对象，而必须通过 Binder 来是的远程服务可以调用自己的服务，所以就有了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(),</span><br><span class="line">                   mMainThread.getHandler(), flags);</span><br></pre></td></tr></table></figure></p>
<p>借助 ServiceDispatcher 来进行这种转换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public final IServiceConnection getServiceDispatcher(ServiceConnection c,</span><br><span class="line">          Context context, Handler handler, int flags) &#123;</span><br><span class="line">      synchronized (mServices) &#123;</span><br><span class="line">          LoadedApk.ServiceDispatcher sd = null;</span><br><span class="line">          ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context);</span><br><span class="line">          if (map != null) &#123;</span><br><span class="line">              sd = map.get(c);</span><br><span class="line">          &#125;</span><br><span class="line">          if (sd == null) &#123;</span><br><span class="line">              sd = new ServiceDispatcher(c, context, handler, flags);</span><br><span class="line">              if (map == null) &#123;</span><br><span class="line">                  map = new ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;();</span><br><span class="line">                  mServices.put(context, map);</span><br><span class="line">              &#125;</span><br><span class="line">              map.put(c, sd);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              sd.validate(context, handler);</span><br><span class="line">          &#125;</span><br><span class="line">          return sd.getIServiceConnection();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这是由 LoadedApk 里面的getServiceDispatcher方法实现的， 从代码中可以看出， ServiceConnection 和 ServiceDispatcher 是一个一一对应的关系，系统会查找当前的 ArrayMap 中是否有当前的 ServiceConnection ，如果有的话，就找出，木有的话，就创建一个新的 ServiceDispatch，在 ServiceDispatch 中有保存了 ServiceConnection 对象， 当 Service 和 客户端建立连接后，系统会调用 IServiceConnection 来调用 ServiceConnection 中的 onServiceConnection 方法，这个方法是一个跨进程的操作。</li>
<li><p>接着 bindServiceCommon 会执行 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActivityManagerNative.getDefault().bindService(</span><br><span class="line">mMainThread.getApplicationThread(), getActivityToken(),</span><br><span class="line">service, service.resolveTypeIfNeeded(getContentResolver()),sd, flags, user.getIdentifier());</span><br></pre></td></tr></table></figure>
<p>很熟悉的节奏，调用 AMS 来继续 Service 的具体绑定流程，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int bindService(IApplicationThread caller, IBinder token,</span><br><span class="line">          Intent service, String resolvedType,</span><br><span class="line">          IServiceConnection connection, int flags, int userId) &#123;</span><br><span class="line">      enforceNotIsolatedCaller(&quot;bindService&quot;);</span><br><span class="line">      if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123;</span><br><span class="line">          throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      synchronized(this) &#123;</span><br><span class="line">          return mServices.bindServiceLocked(caller, token, service, resolvedType,</span><br><span class="line">                  connection, flags, userId);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>AMS 会接着调用 ActiveServices 的bindServiceLocked 函数，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">  int bindServiceLocked(IApplicationThread caller, IBinder token,</span><br><span class="line">            Intent service, String resolvedType,</span><br><span class="line">            IServiceConnection connection, int flags, int userId) &#123;</span><br><span class="line">       </span><br><span class="line">        ActivityRecord activity = null;</span><br><span class="line">        if (token != null) &#123;</span><br><span class="line">            activity = ActivityRecord.isInStackLocked(token);</span><br><span class="line">            if (activity == null) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Binding with unknown activity: &quot; + token);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int clientLabel = 0;</span><br><span class="line">        PendingIntent clientIntent = null;</span><br><span class="line">        if (callerApp.info.uid == Process.SYSTEM_UID) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">               </span><br><span class="line">    clientIntent = (PendingIntent)service.getParcelableExtra(Intent.EXTRA_CLIENT_INTENT);</span><br><span class="line">            &#125; catch (RuntimeException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            if (clientIntent != null) &#123;</span><br><span class="line">                clientLabel = service.getIntExtra(Intent.EXTRA_CLIENT_LABEL, 0);</span><br><span class="line">                if (clientLabel != 0) &#123;</span><br><span class="line">                    service = service.cloneFilter();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        final boolean callerFg = callerApp.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE;</span><br><span class="line">        </span><br><span class="line">        ServiceLookupResult res =</span><br><span class="line">        retrieveServiceLocked(service, resolvedType,</span><br><span class="line">Binder.getCallingPid(), Binder.getCallingUid(), userId, true, callerFg);</span><br><span class="line">        if (res == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (res.record == null) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        ServiceRecord s = res.record;</span><br><span class="line"></span><br><span class="line">        final long origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            if (unscheduleServiceRestartLocked(s)) &#123;</span><br><span class="line">                if (DEBUG_SERVICE) Slog.v(TAG, &quot;BIND SERVICE WHILE RESTART PENDING: &quot; + s);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if ((flags&amp;Context.BIND_AUTO_CREATE) != 0) &#123;</span><br><span class="line">                s.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">                if (!s.hasAutoCreateConnections()) &#123;</span><br><span class="line">                    ProcessStats.ServiceState stracker = s.getTracker();</span><br><span class="line">                    if (stracker != null) &#123;</span><br><span class="line">        stracker.setBound(true,mAm.mProcessStats.getMemFactorLocked(), s.lastActivity);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp);</span><br><span class="line">            ConnectionRecord c = new ConnectionRecord(b, activity,</span><br><span class="line">                    connection, flags, clientLabel, clientIntent);</span><br><span class="line"></span><br><span class="line">            IBinder binder = connection.asBinder();</span><br><span class="line">            ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder);</span><br><span class="line">            if (clist == null) &#123;</span><br><span class="line">                clist = new ArrayList&lt;ConnectionRecord&gt;();</span><br><span class="line">                s.connections.put(binder, clist);</span><br><span class="line">            &#125;</span><br><span class="line">            clist.add(c);</span><br><span class="line">            b.connections.add(c);</span><br><span class="line">            if (activity != null) &#123;</span><br><span class="line">                if (activity.connections == null) &#123;</span><br><span class="line">                    activity.connections = new HashSet&lt;ConnectionRecord&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                activity.connections.add(c);</span><br><span class="line">            &#125;</span><br><span class="line">            b.client.connections.add(c);</span><br><span class="line">            if ((c.flags&amp;Context.BIND_ABOVE_CLIENT) != 0) &#123;</span><br><span class="line">                b.client.hasAboveClient = true;</span><br><span class="line">            &#125;</span><br><span class="line">            clist = mServiceConnections.get(binder);</span><br><span class="line">            if (clist == null) &#123;</span><br><span class="line">                clist = new ArrayList&lt;ConnectionRecord&gt;();</span><br><span class="line">                mServiceConnections.put(binder, clist);</span><br><span class="line">            &#125;</span><br><span class="line">            clist.add(c);</span><br><span class="line"></span><br><span class="line">            if ((flags&amp;Context.BIND_AUTO_CREATE) != 0) &#123;</span><br><span class="line">                s.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">            //此处开始调用 bringUpServiceLocked</span><br><span class="line">                if (bringUpServiceLocked(s, service.getFlags(), callerFg, false) != null) &#123;</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (s.app != null) &#123;</span><br><span class="line">                // This could have made the service more important.</span><br><span class="line">                mAm.updateOomAdjLocked(s.app);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (DEBUG_SERVICE) Slog.v(TAG, &quot;Bind &quot; + s + &quot; with &quot; + b</span><br><span class="line">                    + &quot;: received=&quot; + b.intent.received</span><br><span class="line">                    + &quot; apps=&quot; + b.intent.apps.size()</span><br><span class="line">                    + &quot; doRebind=&quot; + b.intent.doRebind);</span><br><span class="line"></span><br><span class="line">            if (s.app != null &amp;&amp; b.intent.received) &#123;</span><br><span class="line">               </span><br><span class="line">                try &#123;</span><br><span class="line">                    c.conn.connected(s.name, b.intent.binder);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;Failure sending service &quot; + s.shortName</span><br><span class="line">                            + &quot; to connection &quot; + c.conn.asBinder()</span><br><span class="line">                            + &quot; (in &quot; + c.binding.client.processName + &quot;)&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (b.intent.apps.size() == 1 &amp;&amp; b.intent.doRebind) &#123;</span><br><span class="line">                    requestServiceBindingLocked(s, b.intent, callerFg, true);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (!b.intent.requested) &#123;</span><br><span class="line">                requestServiceBindingLocked(s, b.intent, callerFg, false);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            getServiceMap(s.userId).ensureNotStartingBackground(s);</span><br><span class="line"></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在 bingUpServiceLocked 中，在这个函数中，又会调用 realStartServiceLocked 这个函数，这个函数就是之前分析 Service 启动过程的函数，我们有一个在之前 startService 中没有分析的函数：requestServiceBindingsLocked ，这个函数就是我们这次要分析的重点: bind 的过程就是在这个函数中实现的，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private final boolean requestServiceBindingLocked(ServiceRecord r,</span><br><span class="line">         IntentBindRecord i, boolean execInFg, boolean rebind) &#123;</span><br><span class="line">     if (r.app == null || r.app.thread == null) &#123;</span><br><span class="line">         // If service is not currently running, can&apos;t yet bind.</span><br><span class="line">         return false;</span><br><span class="line">     &#125;</span><br><span class="line">     if ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; 0) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">             bumpServiceExecutingLocked(r, execInFg, &quot;bind&quot;);</span><br><span class="line">             r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line"></span><br><span class="line">	//调用 ApplicationThread 的scheduleBindService </span><br><span class="line">             r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span><br><span class="line">                     r.app.repProcState);</span><br><span class="line">             if (!rebind) &#123;</span><br><span class="line">                 i.requested = true;</span><br><span class="line">             &#125;</span><br><span class="line">             i.hasBound = true;</span><br><span class="line">             i.doRebind = false;</span><br><span class="line">         &#125; catch (RemoteException e) &#123;</span><br><span class="line">             if (DEBUG_SERVICE) Slog.v(TAG, &quot;Crashed while binding &quot; + r);</span><br><span class="line">             return false;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p> 可以看出， App.thread 这个对象多次出现，实际上这是一个 ApplicationThread , 同样其内部也会通过 Handler H 来中转，对于 scheduleBindService而言也是这样，H 收到消息后会通过 handleBindService 来处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private void handleBindService(BindServiceData data) &#123;</span><br><span class="line">       Service s = mServices.get(data.token);</span><br><span class="line">       if (DEBUG_SERVICE)</span><br><span class="line">           Slog.v(TAG, &quot;handleBindService s=&quot; + s + &quot; rebind=&quot; + data.rebind);</span><br><span class="line">       if (s != null) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">               try &#123;</span><br><span class="line">                   if (!data.rebind) &#123;</span><br><span class="line"></span><br><span class="line">					//此处执行 onBind 的函数所在</span><br><span class="line">                       IBinder binder = s.onBind(data.intent);</span><br><span class="line"></span><br><span class="line">					// 调用 AMS 的 publishService 函数</span><br><span class="line">                       ActivityManagerNative.getDefault().publishService(</span><br><span class="line">                               data.token, data.intent, binder);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       s.onRebind(data.intent);</span><br><span class="line">                       ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                               data.token, 0, 0, 0);</span><br><span class="line">                   &#125;</span><br><span class="line">                   ensureJitEnabled();</span><br><span class="line">               &#125; catch (RemoteException ex) &#123;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               if (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                   throw new RuntimeException(</span><br><span class="line">                           &quot;Unable to bind to service &quot; + s</span><br><span class="line">                           + &quot; with &quot; + data.intent + &quot;: &quot; + e.toString(), e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> 在该函数中，首先会根据 Service 的token 取出 Service 对象，在调用Service 的onBind 方法，Service 的onBind 方法会返回一个 IBinder 对象，这个在开发中我们都很清楚，但这是 Service 的方法，但这个时候，客户端不清楚已经连接上了，所以还必须和客户端中的 onServiceConnected，这个过程是由如下代码实现的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityManagerNative.getDefault().publishService(</span><br><span class="line"> data.token, data.intent, binder);</span><br></pre></td></tr></table></figure></p>
<p> 前面也多次提到了，ActivityManagerNative.getDefault() 是一个 AMS， 所以上诉的代码其实是在 AMS 中实现的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void publishService(IBinder token, Intent intent, IBinder service) &#123;</span><br><span class="line">       if (intent != null &amp;&amp; intent.hasFileDescriptors() == true)         &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       synchronized(this) &#123;</span><br><span class="line">           if (!(token instanceof ServiceRecord)) &#123;</span><br><span class="line">               throw new IllegalArgumentException(&quot;Invalid service token&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           mServices.publishServiceLocked((ServiceRecord)token, intent, service);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> 上面可以看到会调用 mServices 的 publicServiceLocked 函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">void publishServiceLocked(ServiceRecord r, Intent intent, IBinder service) &#123;</span><br><span class="line">       final long origId = Binder.clearCallingIdentity();</span><br><span class="line">       try &#123;</span><br><span class="line">           if (DEBUG_SERVICE) Slog.v(TAG, &quot;PUBLISHING &quot; + r</span><br><span class="line">                   + &quot; &quot; + intent + &quot;: &quot; + service);</span><br><span class="line">           if (r != null) &#123;</span><br><span class="line">               Intent.FilterComparison filter</span><br><span class="line">                       = new Intent.FilterComparison(intent);</span><br><span class="line">               IntentBindRecord b = r.bindings.get(filter);</span><br><span class="line">               if (b != null &amp;&amp; !b.received) &#123;</span><br><span class="line">                   b.binder = service;</span><br><span class="line">                   b.requested = true;</span><br><span class="line">                   b.received = true;</span><br><span class="line">                   for (int conni=r.connections.size()-1; conni&gt;=0; conni--) &#123;</span><br><span class="line">                       ArrayList&lt;ConnectionRecord&gt; clist = r.connections.valueAt(conni);</span><br><span class="line">                       for (int i=0; i&lt;clist.size(); i++) &#123;</span><br><span class="line">                           ConnectionRecord c = clist.get(i);</span><br><span class="line">                           if (!filter.equals(c.binding.intent.intent)) &#123;</span><br><span class="line">                               if (DEBUG_SERVICE) Slog.v(</span><br><span class="line">                                       TAG, &quot;Not publishing to: &quot; + c);</span><br><span class="line">                               if (DEBUG_SERVICE) Slog.v(</span><br><span class="line">                                       TAG, &quot;Bound intent: &quot; + c.binding.intent.intent);</span><br><span class="line">                               if (DEBUG_SERVICE) Slog.v(</span><br><span class="line">                                       TAG, &quot;Published intent: &quot; + intent);</span><br><span class="line">                               continue;</span><br><span class="line">                           &#125;</span><br><span class="line">                           if (DEBUG_SERVICE) Slog.v(TAG, &quot;Publishing to: &quot; + c);</span><br><span class="line">                           try &#123;</span><br><span class="line">                           //此处为核心代码</span><br><span class="line">                               c.conn.connected(r.name, service);</span><br><span class="line">                           &#125; catch (Exception e) &#123;</span><br><span class="line">                               Slog.w(TAG, &quot;Failure sending service &quot; + r.name +</span><br><span class="line">                                     &quot; to connection &quot; + c.conn.asBinder() +</span><br><span class="line">                                     &quot; (in &quot; + c.binding.client.processName + &quot;)&quot;, e);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), false);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           Binder.restoreCallingIdentity(origId);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> 核心代码就只有一个:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.conn.connected(r.name, service);</span><br></pre></td></tr></table></figure></p>
<p> c 的类型是 ConnectionRecord， c.conn 的类型是 ServiceDispatcher.innerConnection, service 就是 Service 的onBind 方法返回的 Binder 对象，我们可以看一下 ServiceDispatcher.innerConnection 的定义，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static class InnerConnection extends IServiceConnection.Stub &#123;</span><br><span class="line">          final WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher;</span><br><span class="line"></span><br><span class="line">          InnerConnection(LoadedApk.ServiceDispatcher sd) &#123;</span><br><span class="line">              mDispatcher = new WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          public void connected(ComponentName name, IBinder service) throws RemoteException &#123;</span><br><span class="line">              LoadedApk.ServiceDispatcher sd = mDispatcher.get();</span><br><span class="line">              if (sd != null) &#123;</span><br><span class="line">                  sd.connected(name, service);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></p>
<p> 该函数是定义在 LoadedApk 中的一个内部类，我们可以看到 innerconnection 其实调用的还是 ServiceDiapatcher 的connect 代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void connected(ComponentName name, IBinder service) &#123;</span><br><span class="line">          if (mActivityThread != null) &#123;</span><br><span class="line">              mActivityThread.post(new RunConnection(name, service, 0));</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              doConnected(name, service);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p> 可以看到，调用了mActivityThread 这样的一个 Handler，并且这个就是我们在activityThread中的 H，从前面的创建来说， mActivityThread 是肯定不会为空的，所以，我们就要调用 Handler 的Post 方法，从而将函数运行在主线程中，这样，客户端的 ServiceConnection 的方法就会在主线程中被回调。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">private final class RunConnection implements Runnable &#123;</span><br><span class="line">           RunConnection(ComponentName name, IBinder service, int command) &#123;</span><br><span class="line">               mName = name;</span><br><span class="line">               mService = service;</span><br><span class="line">               mCommand = command;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           public void run() &#123;</span><br><span class="line">               if (mCommand == 0) &#123;</span><br><span class="line">                   doConnected(mName, mService);</span><br><span class="line">               &#125; else if (mCommand == 1) &#123;</span><br><span class="line">                   doDeath(mName, mService);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           final ComponentName mName;</span><br><span class="line">           final IBinder mService;</span><br><span class="line">           final int mCommand;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       public void doConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">           ServiceDispatcher.ConnectionInfo old;</span><br><span class="line">           ServiceDispatcher.ConnectionInfo info;</span><br><span class="line"></span><br><span class="line">           synchronized (this) &#123;</span><br><span class="line">               if (mForgotten) &#123;</span><br><span class="line">                   // We unbound before receiving the connection; ignore</span><br><span class="line">                   // any connection received.</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">               old = mActiveConnections.get(name);</span><br><span class="line">               if (old != null &amp;&amp; old.binder == service) &#123;</span><br><span class="line">                   // Huh, already have this one.  Oh well!</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (service != null) &#123;</span><br><span class="line">                   // A new service is being connected... set it all up.</span><br><span class="line">                   mDied = false;</span><br><span class="line">                   info = new ConnectionInfo();</span><br><span class="line">                   info.binder = service;</span><br><span class="line">                   info.deathMonitor = new DeathMonitor(name, service);</span><br><span class="line">                   try &#123;</span><br><span class="line">                       service.linkToDeath(info.deathMonitor, 0);</span><br><span class="line">                       mActiveConnections.put(name, info);</span><br><span class="line">                   &#125; catch (RemoteException e) &#123;</span><br><span class="line">                       // This service was dead before we got it...  just</span><br><span class="line">                       // don&apos;t do anything with it.</span><br><span class="line">                       mActiveConnections.remove(name);</span><br><span class="line">                       return;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   // The named service is being disconnected... clean up.</span><br><span class="line">                   mActiveConnections.remove(name);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (old != null) &#123;</span><br><span class="line">                   old.binder.unlinkToDeath(old.deathMonitor, 0);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // If there was an old service, it is not disconnected.</span><br><span class="line">           if (old != null) &#123;</span><br><span class="line">               mConnection.onServiceDisconnected(name);</span><br><span class="line">           &#125;</span><br><span class="line">           // If there is a new service, it is now connected.</span><br><span class="line">           if (service != null) &#123;</span><br><span class="line">               mConnection.onServiceConnected(name, service);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p> 可以看到，Runnection 也就是简单调用了 doConnected 的方法，由于 ServiceDispatcher 中保存了 客户端的 ServiceConnection ，所以，我们可以很方便的调用 ServiceConnection 的 onServiceConnection，至此，activity 和 service 的绑定过程就分析完成了。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="/2016/04/21/Service-分析/#comment" class="comment-link">评论</a>
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
  
  <div class="tags">
    <a href="/tags/android-service/">android service</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-Service-分析" data-title="Service 分析" data-url="http://yoursite.com/2016/04/21/Service-分析/"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
  var duoshuoQuery = {short_name:'huronghui'};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
       || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
  <!-- 多说公共JS代码 end -->

</section>


</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/blog/">blog</a><small>5</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2016/05/01/android-studio-使用Maven-仓库/">android studio 使用Maven 仓库</a>
      </li>
    
      <li>
        <a href="/2016/04/28/android-异步（二）AsyncTask/">android 异步（二）AsyncTask</a>
      </li>
    
      <li>
        <a href="/2016/04/27/android-线程解析/">android 线程解析</a>
      </li>
    
      <li>
        <a href="/2016/04/25/GreenDao-初步使用/">GreenDao 初步使用</a>
      </li>
    
      <li>
        <a href="/2016/04/23/RecyclerView-初始以及设置点击事件/">RecyclerView 初始以及设置点击事件（一）</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/android-GreenDao/">android GreenDao</a><small>1</small></li>
  
    <li><a href="/tags/android-Handler/">android Handler</a><small>2</small></li>
  
    <li><a href="/tags/android-RecyclerView/">android RecyclerView</a><small>1</small></li>
  
    <li><a href="/tags/android-View/">android View</a><small>1</small></li>
  
    <li><a href="/tags/android-activity/">android activity</a><small>1</small></li>
  
    <li><a href="/tags/android-maven-AS/">android maven AS</a><small>1</small></li>
  
    <li><a href="/tags/android-service/">android service</a><small>1</small></li>
  
    <li><a href="/tags/android-window/">android window</a><small>2</small></li>
  
    <li><a href="/tags/android-事件分发/">android 事件分发</a><small>2</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/android-GreenDao/" style="font-size: 10px;">android GreenDao</a> <a href="/tags/android-Handler/" style="font-size: 20px;">android Handler</a> <a href="/tags/android-RecyclerView/" style="font-size: 10px;">android RecyclerView</a> <a href="/tags/android-View/" style="font-size: 10px;">android View</a> <a href="/tags/android-activity/" style="font-size: 10px;">android activity</a> <a href="/tags/android-maven-AS/" style="font-size: 10px;">android maven AS</a> <a href="/tags/android-service/" style="font-size: 10px;">android service</a> <a href="/tags/android-window/" style="font-size: 20px;">android window</a> <a href="/tags/android-事件分发/" style="font-size: 20px;">android 事件分发</a>
  </div>
</div>


  <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=5&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=2203673484&verifier=607c53d8&dpc=1"></iframe>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2016 huronghui
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id='bg'></div>
</body>
</html>