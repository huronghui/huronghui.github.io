<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  
  <title>android 异步（二）AsyncTask | 霜白</title>
  <meta name="author" content="huronghui" />

  
  <meta name="description" content="android" />
  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <meta property="og:title" content="android 异步（二）AsyncTask" />
  <meta property="og:site_name" content="霜白" />

  
  

  
    <meta property="og:image" content="undefined" />
  

  
  <link href="/css/images/favicon.ico" rel="icon" />
  

  <link rel="alternate" href="/atom.xml" title="霜白" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">霜白</a></h1>
  <h2><a href="/">栀年年年</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-28T04:47:15.000Z"><a href="/2016/04/28/android-异步（二）AsyncTask/">2016-04-28</a></time>
      
      
  
    <h1 class="title">android 异步（二）AsyncTask</h1>
  

    </header>
    <div class="entry">
      
        <p>在Android 的异步消息中，除了 Handler 以外，还包含 AsyncTask， HandlerThread， IntentService，今天我们先讲解一下 AsyncTask。</p>
<p>###AsyncTask<br>AsyncTask 是一个轻量级的异步任务类，他可以在线程中执行后台任务，然后将执行的进度和执行的结果传递到UI线程中，更新界面<br>AsyncTask 是一个抽闲该类，我们如果如果想要使用它，就要创建一个子类去继承，并且需要指定三个泛型参数：</p>
<ol>
<li>Params<br>在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。</li>
<li>Progress<br>后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。</li>
<li>Result<br>当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。</li>
</ol>
<a id="more"></a>
<p>需要注意的是，如果 AsyncTask 不需要传递任何具体的参数，这三个参数是可以使用 void 来代替的，一个典型的声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123;  </span><br><span class="line">    ……  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但这只是声明，我们如果要完成任务的定制，就需要重写里面的方法，一般需要经常重写的方法有四个：</p>
<ol>
<li><p>onPreExecute()<br>在主线程之中执行，在异步任务执行之前执行，该方法会被调用，常用于一些界面上的初始化，比如显示一个进度条等等的一些准备工作</p>
</li>
<li><p>doInBackground(Params…)<br>这个方法中的代码会在线程池的子线程中执行，用于异步任务，所以我们要做的耗时操作都应该放到这个函数中执行， 参数 Params 是异步任务的输入参数，在该方法中可以通过 publishProgress(Progress) 函数来反馈当前任务的执行进度，任务一旦完成就将任务的结果返回，如果第三个泛型参数为 void，那么就可以不用返回任何执行结果</p>
</li>
<li><p>onProgressUpdate(Progress…)<br>当在后台任务中调用了publishProgress(Progress…)方法后，这个方法就很快会被调用，方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新。</p>
</li>
<li>onPostExecute(Result)<br>当后台任务执行完毕并通过return语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些UI操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等。 Result 是后台任务的返回值，即 doInBackground 返回的值</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    protected void onPreExecute() &#123;  </span><br><span class="line">        progressDialog.show();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    protected Boolean doInBackground(Void... params) &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            while (true) &#123;  </span><br><span class="line">                int downloadPercent = doDownload();  </span><br><span class="line">                publishProgress(downloadPercent);  </span><br><span class="line">                if (downloadPercent &gt;= 100) &#123;  </span><br><span class="line">                    break;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; catch (Exception e) &#123;  </span><br><span class="line">            return false;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return true;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    protected void onProgressUpdate(Integer... values) &#123;  </span><br><span class="line">        progressDialog.setMessage(&quot;当前下载进度：&quot; + values[0] + &quot;%&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    protected void onPostExecute(Boolean result) &#123;  </span><br><span class="line">        progressDialog.dismiss();  </span><br><span class="line">        if (result) &#123;  </span><br><span class="line">            Toast.makeText(context, &quot;下载成功&quot;, Toast.LENGTH_SHORT).show();  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            Toast.makeText(context, &quot;下载失败&quot;, Toast.LENGTH_SHORT).show();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 上面就是一个 AsyncTask 的典型用法，可以清楚看到，在 doInBackground 中执行的具体的逻辑操作，在 onProgressUpdate 中显示当前的下载进度，在 onPostExecute 中是将显示下载后的界面显示，如果想要启动我们的任务，就只要执行下面一个胆码就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new DownloadTask().execute();</span><br></pre></td></tr></table></figure></p>
<p>这样一来，是不是感觉我们更新界面比用Handler要简单的多，只要实现相应的函数就可以了。</p>
<p>###源码分析<br>我们知道了 AsyncTask 的使用，但他的内部逻辑是什么样的，我们还是一无所知，所以，我们要从源码的角度来解析一下，首先先看一下他的构造函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public AsyncTask() &#123;</span><br><span class="line">       mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line"></span><br><span class="line">		 //call方法被调用后,将设置优先级为后台级别,然后调用AsyncTask的doInBackground方法  </span><br><span class="line">           public Result call() throws Exception &#123;</span><br><span class="line">               mTaskInvoked.set(true);</span><br><span class="line"></span><br><span class="line">               Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">               //noinspection unchecked</span><br><span class="line">               return postResult(doInBackground(mParams));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">	//在mFuture实例中,将会调用mWorker做后台任务,完成后会调用done方法  </span><br><span class="line">       mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">           @Override</span><br><span class="line">           protected void done() &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   postResultIfNotInvoked(get());</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   android.util.Log.w(LOG_TAG, e);</span><br><span class="line">               &#125; catch (ExecutionException e) &#123;</span><br><span class="line">                   throw new RuntimeException(&quot;An error occured while executing doInBackground()&quot;,</span><br><span class="line">                           e.getCause());</span><br><span class="line">               &#125; catch (CancellationException e) &#123;</span><br><span class="line">                   postResultIfNotInvoked(null);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，构造函数中没有任何有效的逻辑执行，只是声明了两个初始变量， mWorker 和 mFuture，并且在初始化的是和，将 mWorker 作为参数传递到 mFuture 中<br>如果我们要启用以恶搞任务，就要调用改任务的 execute() 函数，所以这应该是我们的核心所在，我们看一下他的源码，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</span><br><span class="line">       return executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> 我们调用了 executeOnExecutor() 方法，那么具体的方法应该就是在这个方法中了，那么就进去看一下吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,</span><br><span class="line">           Params... params) &#123;</span><br><span class="line">       if (mStatus != Status.PENDING) &#123;</span><br><span class="line">           switch (mStatus) &#123;</span><br><span class="line">               case RUNNING:</span><br><span class="line">                   throw new IllegalStateException(&quot;Cannot execute task:&quot;</span><br><span class="line">                           + &quot; the task is already running.&quot;);</span><br><span class="line">               case FINISHED:</span><br><span class="line">                   throw new IllegalStateException(&quot;Cannot execute task:&quot;</span><br><span class="line">                           + &quot; the task has already been executed &quot;</span><br><span class="line">                           + &quot;(a task can be executed only once)&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mStatus = Status.RUNNING;</span><br><span class="line">       onPreExecute();</span><br><span class="line">       mWorker.mParams = params;</span><br><span class="line">       exec.execute(mFuture);</span><br><span class="line">       return this;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到在 16 行 调用了 onPreExecute 方法，所以我们就可以证实了 onPreExecute 是第一个得到执行的，然后我们把我们传递的参数放到 Worker 中，并调用了 exec 的ececute 的方法，我们在函数的传递参数中可以知道 exec 是一个SerialExecutor类的实例，这个SerialExecutor是 AsyncTask的内部类，所以exec.execute(mFuture)，实际上执行的是 SerialExecutor 的 execute 方法，我们看下这个类的具体使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private static class SerialExecutor implements Executor &#123;</span><br><span class="line">       final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">       Runnable mActive;</span><br><span class="line"></span><br><span class="line">       public synchronized void execute(final Runnable r) &#123;</span><br><span class="line">           mTasks.offer(new Runnable() &#123;</span><br><span class="line">               public void run() &#123;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       r.run();</span><br><span class="line">                   &#125; finally &#123;</span><br><span class="line">                       scheduleNext();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           if (mActive == null) &#123;</span><br><span class="line">               scheduleNext();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       protected synchronized void scheduleNext() &#123;</span><br><span class="line">           if ((mActive = mTasks.poll()) != null) &#123;</span><br><span class="line">               THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> 很简单的一个类，里面也没有多少函数， execute 方法也很好理解，就是我们会获取一个线程队列，把我们得到的 Runnable 放入到队列中， 并且在最后会调用 scheduleNext 来获取下一个线程并执行其 run 方法，而我们传入进去的线程就是我们的 FutureTask，所以 他的run方法其实就是我们在类初始化总的 worker 的call 方法，我们在回顾一下他的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line"></span><br><span class="line">	 //call方法被调用后,将设置优先级为后台级别,然后调用AsyncTask的doInBackground方法  </span><br><span class="line">          public Result call() throws Exception &#123;</span><br><span class="line">              mTaskInvoked.set(true);</span><br><span class="line"></span><br><span class="line">              Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">              //noinspection unchecked</span><br><span class="line">              return postResult(doInBackground(mParams));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure></p>
<p> 这是再看这个代码应该就很简单了，首先现将当前的线程设为 true，然后执行 postResult 方法，在这个方法中会调用 doInBackground 方法，因此 我们前面的结论 doInbackground 是一个逻辑执行函数 的猜想是正确的，这是一个在子线程中执行的函数，那么什么时候回将我们的结果发送大主线程呢？就是在这个 postResult 中，我们看下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Result postResult(Result result) &#123;</span><br><span class="line">      @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">      Message message = sHandler.obtainMessage(MESSAGE_POST_RESULT,</span><br><span class="line">              new AsyncTaskResult&lt;Result&gt;(this, result));</span><br><span class="line">      message.sendToTarget();</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p> 似不似很熟悉，有木有觉得和上篇中讲的 handler 的代码很像，这里不但很想，而且就是一样的，因此 AsyncTask 其实底层使用的还是 Handler 来传递消息给主线程，这里也是一样，这里是携带了一个 MESSAGE_POST_RESULT 的消息给 sHandler ，这个 sHandler 是 InternalHandler 的实例，并且这个消息将会在 InternalHandler 的handlerMessage 中进行处理，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private static class InternalHandler extends Handler &#123;</span><br><span class="line">       @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</span><br><span class="line">       @Override</span><br><span class="line">       public void handleMessage(Message msg) &#123;</span><br><span class="line">           AsyncTaskResult result = (AsyncTaskResult) msg.obj;</span><br><span class="line">           switch (msg.what) &#123;</span><br><span class="line">               case MESSAGE_POST_RESULT:</span><br><span class="line">                   // There is only one result</span><br><span class="line">                   result.mTask.finish(result.mData[0]);</span><br><span class="line">                   break;</span><br><span class="line">               case MESSAGE_POST_PROGRESS:</span><br><span class="line">                   result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                   break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> 可以看出，如果消息是 MESSAGE_POST_RESULT ，就会执行 finish 函数，如果是 MESSAGE_POST_PROGRESS，就会执行 onProgressUpdate 函数，因为我们在 postResult 中发出的是 MESSAGE_POST_RESULT ，所以就会执行 finish 函数，看下源码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void finish(Result result) &#123;</span><br><span class="line">       if (isCancelled()) &#123;</span><br><span class="line">           onCancelled(result);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           onPostExecute(result);</span><br><span class="line">       &#125;</span><br><span class="line">       mStatus = Status.FINISHED;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> 至此，我们可以看到最后一个函数，onPostExecute，我们将之前在 ondoInBackgroung 中获得的 result 传递给 onPostExecute，并且这个执行是在 handler 中，也就是我们的主线程之中</p>
<h3 id="Ps"><a href="#Ps" class="headerlink" title="Ps"></a>Ps</h3><p> 刚才我们在分析 SerialExecutor 的时候，其实木有分析的完全，只是分析了他会调用 FutureTask 的 run 方法，但至于什么时候会在调用并没有研究，这里其实就是 android3.0 以后有所改动的地方，在 AsyncTask 中， SerialExecutor 是作为常量使用的，也就是说，所有的 AsyncTask 都是在用 SerialExecutor ，我们在看一下这个类，回顾一下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> private static class SerialExecutor implements Executor &#123;  </span><br><span class="line">    final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();  </span><br><span class="line">    Runnable mActive;  </span><br><span class="line">  </span><br><span class="line">    public synchronized void execute(final Runnable r) &#123;  </span><br><span class="line">        mTasks.offer(new Runnable() &#123;  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                try &#123;  </span><br><span class="line">                    r.run();  </span><br><span class="line">                &#125; finally &#123;  </span><br><span class="line">                    scheduleNext();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        if (mActive == null) &#123;  </span><br><span class="line">            scheduleNext();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    protected synchronized void scheduleNext() &#123;  </span><br><span class="line">        if ((mActive = mTasks.poll()) != null) &#123;  </span><br><span class="line">            THREAD_POOL_EXECUTOR.execute(mActive);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 可以看到，SerialExecutor 是使用 一个队列来管理 Runnable 对象的，当我们启动第一个任务的时候，也就是第一次运行 execute 的时候，会将 我们的任务 通过 offer 方法传递到队列的尾部，然后判断 mActive 对象是不是等于 null，第一次运行的是，该值肯定为 null，于是就会调用 scheduleNext 获取队列的头部并赋值给 mActive，然后调用 THREAD_POOL_EXECUTOR 去执行取出的取出的 Runnable 对象。之后如果新的任务被执行，同样还会调用offer()方法将传入的Runnable添加到队列的尾部，但是再去给mActive对象做非空检查的时候就会发现mActive对象已经不再是null了，于是就不会再调用scheduleNext()方法。</p>
<p> 在 offer 里面，我们使用的是 try finally 方法，也就是说无论什么情况，scheduleNext 方法都会执行，并且当一个任务执行完毕，才会执行下一个任务，这是在模仿单一线程池的效果，如果我们快速启动恩多任务，也只会有一个线程在执行，其余都是等待状态。但是在 3.0 之前，android 是没有这个类的，也就是说，在3.0 之前的 ，线程运行顺序是无序。</p>
<p> 参考资料：<br> <a href="http://blog.csdn.net/guolin_blog/article/details/11711405" target="_blank" rel="external"> Android AsyncTask完全解析，带你从源码的角度彻底理解</a></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="/2016/04/28/android-异步（二）AsyncTask/#comment" class="comment-link">评论</a>
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
  
  <div class="tags">
    <a href="/tags/android-Handler/">android Handler</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-android-异步（二）AsyncTask" data-title="android 异步（二）AsyncTask" data-url="http://yoursite.com/2016/04/28/android-异步（二）AsyncTask/"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
  var duoshuoQuery = {short_name:'huronghui'};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
       || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
  <!-- 多说公共JS代码 end -->

</section>


</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/blog/">blog</a><small>5</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2016/05/01/android-studio-使用Maven-仓库/">android studio 使用Maven 仓库</a>
      </li>
    
      <li>
        <a href="/2016/04/28/android-异步（二）AsyncTask/">android 异步（二）AsyncTask</a>
      </li>
    
      <li>
        <a href="/2016/04/27/android-线程解析/">android 线程解析</a>
      </li>
    
      <li>
        <a href="/2016/04/25/GreenDao-初步使用/">GreenDao 初步使用</a>
      </li>
    
      <li>
        <a href="/2016/04/23/RecyclerView-初始以及设置点击事件/">RecyclerView 初始以及设置点击事件（一）</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/android-GreenDao/">android GreenDao</a><small>1</small></li>
  
    <li><a href="/tags/android-Handler/">android Handler</a><small>2</small></li>
  
    <li><a href="/tags/android-RecyclerView/">android RecyclerView</a><small>1</small></li>
  
    <li><a href="/tags/android-View/">android View</a><small>1</small></li>
  
    <li><a href="/tags/android-activity/">android activity</a><small>1</small></li>
  
    <li><a href="/tags/android-maven-AS/">android maven AS</a><small>1</small></li>
  
    <li><a href="/tags/android-service/">android service</a><small>1</small></li>
  
    <li><a href="/tags/android-window/">android window</a><small>2</small></li>
  
    <li><a href="/tags/android-事件分发/">android 事件分发</a><small>2</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/android-GreenDao/" style="font-size: 10px;">android GreenDao</a> <a href="/tags/android-Handler/" style="font-size: 20px;">android Handler</a> <a href="/tags/android-RecyclerView/" style="font-size: 10px;">android RecyclerView</a> <a href="/tags/android-View/" style="font-size: 10px;">android View</a> <a href="/tags/android-activity/" style="font-size: 10px;">android activity</a> <a href="/tags/android-maven-AS/" style="font-size: 10px;">android maven AS</a> <a href="/tags/android-service/" style="font-size: 10px;">android service</a> <a href="/tags/android-window/" style="font-size: 20px;">android window</a> <a href="/tags/android-事件分发/" style="font-size: 20px;">android 事件分发</a>
  </div>
</div>


  <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=5&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=2203673484&verifier=607c53d8&dpc=1"></iframe>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2016 huronghui
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id='bg'></div>
</body>
</html>