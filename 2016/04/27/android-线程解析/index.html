<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  
  <title>android 线程解析 | 霜白</title>
  <meta name="author" content="huronghui" />

  
  <meta name="description" content="android" />
  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <meta property="og:title" content="android 线程解析" />
  <meta property="og:site_name" content="霜白" />

  
  

  
    <meta property="og:image" content="undefined" />
  

  
  <link href="/css/images/favicon.ico" rel="icon" />
  

  <link rel="alternate" href="/atom.xml" title="霜白" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">霜白</a></h1>
  <h2><a href="/">栀年年年</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-27T10:18:57.000Z"><a href="/2016/04/27/android-线程解析/">2016-04-27</a></time>
      
      
  
    <h1 class="title">android 线程解析</h1>
  

    </header>
    <div class="entry">
      
        <h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>在 Android 中，如果我们想要使用异步加载，我想第一反应应该都是使用 Handler，通过 Handler 发送消息并在 handleMessage 中具体处理接收到的消息，我们看一下具体使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Handler mHandler=new Handler()</span><br><span class="line">  &#123;</span><br><span class="line">      public void handleMessage(Message msg)</span><br><span class="line">      &#123;</span><br><span class="line">          super.handleMessage(msg);</span><br><span class="line">          //具体的消息处理机制</span><br><span class="line">          。。。</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">    mHandler.sendEmptyMessage(0);</span><br></pre></td></tr></table></figure></p>
<p> 那么问题来了，为什么 Handler 可以实现异步加载呢？原理还是需要我们进入源码看一下，先看一下 Handler 的初始化：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public Handler() &#123;</span><br><span class="line">       this(null, false);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"> public Handler(Callback callback, boolean async) &#123;</span><br><span class="line">       </span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">       //获取当前线程的 Looper 对象，如果获取不到，则会出错</span><br><span class="line">       //需要注意的是，线程是不会默认创建 Looper 的，</span><br><span class="line">       //所以如果线程想要使用 Handler 就需要自己创建 Looper</span><br><span class="line">       mLooper = Looper.myLooper();</span><br><span class="line">       if (mLooper == null) &#123;</span><br><span class="line">           throw new RuntimeException(</span><br><span class="line">               &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">	//获取当前 Looper 对象中的消息队列</span><br><span class="line">       mQueue = mLooper.mQueue;</span><br><span class="line">       mCallback = callback;</span><br><span class="line">       mAsynchronous = async;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> 可以看到在 Handler 的初始化中，我们要用到这几个类： Looper， Queue。这两个就是 Handler 的核心所在，我们会在后面再详细解答这两个的含义以及作用。<br> 再看一下 我们通过 Handler 发送消息的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  public final boolean sendEmptyMessage(int what)</span><br><span class="line">    &#123;</span><br><span class="line">        return sendEmptyMessageDelayed(what, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  public final boolean sendMessage(Message msg)</span><br><span class="line">    &#123;</span><br><span class="line">        return sendMessageDelayed(msg, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public final boolean sendMessageDelayed(Message msg, long delayMillis)</span><br><span class="line">    &#123;</span><br><span class="line">        if (delayMillis &lt; 0) &#123;</span><br><span class="line">            delayMillis = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class="line"></span><br><span class="line">	    //获取到消息队列，然后将我们的消息放入到消息队列中</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        if (queue == null) &#123;</span><br><span class="line">            RuntimeException e = new RuntimeException(</span><br><span class="line">                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class="line">            Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		//会执行 MessageQueue 的 enqueueMessage 方法，将消息放到队列中</span><br><span class="line">        return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p> 可以看到，虽然经过好几个函数，但最终都是汇总到了一个函数中，<strong>enqueueMessage(queue, msg, uptimeMillis)</strong>，并且在 sendMessageAtTime 函数中，我们看到了一个类 MessageQueue，这个 MwssageQueue 就是我们在初始化函数中看到的 queue 对象，我们再看一下sendMessage 的汇总函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">       msg.target = this;</span><br><span class="line">       if (mAsynchronous) &#123;</span><br><span class="line">           msg.setAsynchronous(true);</span><br><span class="line">       &#125;</span><br><span class="line">       return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> 可以看出，实际上调用的 MessageQueue 的 enqueueMessage 方法。<br> 再看下具体的处理消息的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line"></span><br><span class="line">   //此处为一个空的方法，需要我们自己定义实现</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p> 至此，我们在 Handler 类中常用的函数就分析完了，我们可以感觉到，Handler 其实没有做什么，基本工作都是交给了一些支持类，比如 looper，比如 MessageQueue，我们可以先看两张图，了解这些类之间的关系<br> <img src="http://upload-images.jianshu.io/upload_images/680065-d28eda1ceb1af241.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="此处输入图片的描述"><br><img src="http://upload-images.jianshu.io/upload_images/680065-0ed8a2fab7a3ef2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="此处输入图片的描述"><br>，我们可以看出，Looper 的作用是维护一个MessageQueue 并且不停循环发送消息，而messageQueue 就是一个辅助类，用来维护消息的一个队列。</p>
<p>###ThreadLocal<br>在谈到 Looper 之前，我觉得我们应该先谈一下 另外一个类 ThreadLocal，这个类是什么？为什么我们需要使用这个类呢？<br>我们先谈一下这个类的作用场景：当你所在的类，需要多个线程，并且每个线程之间具有不同的数据副本时，就可以使用 ThreadLocal 这个类了，所以这也是我们为什么要在介绍 Looper 之前 先介绍这个类的原因，因为我们每个线程都会维自己的Looper对象，并且每个Looper对象中还会维护一个消息队列，这时我们就需要使用到ThreadLocal 类了。</p>
<p> ThreadLocal是为了隔离多个线程的数据共享。每个线程拥有自己的对象，不会和其他线程发生数据竞争。<br>另外，它们之间也不应该发生数据竞争，因为既然使用了ThreadLocal，说明每个线程都有自己的数据，并且和其他的线程不同。<br>所以，ThreadLocal并不是为了解决数据竞争的问题，解决数据竞争是指用同步、锁等来协调多个线程对同一个数据的访问，而使用ThreadLocal时，每个线程存储的是不同的数据。</p>
<p>它只是能够在不同的线程下，通过同一个ThreadLocal访问到各自的数据。了解了他的功能，我们就分析一下他的内部实现，该类是一个泛型类，所以最重要的便是该类的 set 以及 get 方法了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">        Thread currentThread = Thread.currentThread();</span><br><span class="line">        Values values = values(currentThread);</span><br><span class="line">        if (values == null) &#123;</span><br><span class="line">            values = initializeValues(currentThread);</span><br><span class="line">        &#125;</span><br><span class="line">        values.put(this, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p> ThreadLocal 中的 set 方法中，先获取当前线程名，再根据当前线程名获取其中的值 Values，如果当前的 Values 为null，就初始化，不然就调用 put 方法，那么 Values 又是怎样实现不同的线程之间数据隔离的呢？<br> 这就涉及到 ThreadLocal 内部的一个类，Values：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">static class Values &#123;</span><br><span class="line"></span><br><span class="line">        private static final int INITIAL_SIZE = 16;</span><br><span class="line"></span><br><span class="line">        private static final Object TOMBSTONE = new Object();</span><br><span class="line"></span><br><span class="line">        private Object[] table;</span><br><span class="line"></span><br><span class="line">        private int mask;</span><br><span class="line"></span><br><span class="line">        private int size;</span><br><span class="line"></span><br><span class="line">        private int tombstones;</span><br><span class="line"></span><br><span class="line">        private int maximumLoad;</span><br><span class="line"></span><br><span class="line">        private int clean;</span><br><span class="line"></span><br><span class="line">        Values() &#123;</span><br><span class="line">            initializeTable(INITIAL_SIZE);</span><br><span class="line">            this.size = 0;</span><br><span class="line">            this.tombstones = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Values(Values fromParent) &#123;</span><br><span class="line">            this.table = fromParent.table.clone();</span><br><span class="line">            this.mask = fromParent.mask;</span><br><span class="line">            this.size = fromParent.size;</span><br><span class="line">            this.tombstones = fromParent.tombstones;</span><br><span class="line">            this.maximumLoad = fromParent.maximumLoad;</span><br><span class="line">            this.clean = fromParent.clean;</span><br><span class="line">            inheritValues(fromParent);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         void put(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line">            cleanUp();</span><br><span class="line">            int firstTombstone = -1;</span><br><span class="line"></span><br><span class="line">            for (int index = key.hash &amp; mask;; index = next(index)) &#123;</span><br><span class="line">                Object k = table[index];</span><br><span class="line"></span><br><span class="line">                if (k == key.reference) &#123;</span><br><span class="line">                    table[index + 1] = value;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (k == null) &#123;</span><br><span class="line">                    if (firstTombstone == -1) &#123;</span><br><span class="line">                        table[index] = key.reference;</span><br><span class="line">                        table[index + 1] = value;</span><br><span class="line">                        size++;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    table[firstTombstone] = key.reference;</span><br><span class="line">                    table[firstTombstone + 1] = value;</span><br><span class="line">                    tombstones--;</span><br><span class="line">                    size++;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (firstTombstone == -1 &amp;&amp; k == TOMBSTONE) &#123;</span><br><span class="line">                    firstTombstone = index;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>在 Values 中有一个内部数组 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Object[] table;</span><br></pre></td></tr></table></figure></p>
<p> ThreadLocal 的值就存储在这个数组中，其put方法也同上所述，我们就不具体分析其实现，就说一下结果：<br> 就是我们要存储的值总是在 ThreadLocal 的reference字段所标识的对象的下一个，也就是 40行 到 44行所述</p>
<p> 分析完 set 方法，我们分析一下 get 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line"></span><br><span class="line">        Thread currentThread = Thread.currentThread();</span><br><span class="line">        Values values = values(currentThread);</span><br><span class="line">        if (values != null) &#123;</span><br><span class="line">            Object[] table = values.table;</span><br><span class="line">            int index = hash &amp; values.mask;</span><br><span class="line">            if (this.reference == table[index]) &#123;</span><br><span class="line">                return (T) table[index + 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            values = initializeValues(currentThread);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (T) values.getAfterMiss(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>代码相当简短，同样是获取当前线程的 values 值，然后根据 reference 的值获取相应的值，从这个函数中可以看出，他们操作的都是当前数组的 values 值，这就相当于产生了一个隔离的效果。</p>
<p>###Looper<br>之前那张图我们说了，Looper 在android 的消息机制中扮演的是消息循环的角色，具体而言就是会不停的从 MessageQueue 中取出消息，如果有新消息，就立刻处理分发，否则就阻塞在那里，同样先看一下他的构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">       mQueue = new MessageQueue(quitAllowed);</span><br><span class="line">       mRun = true;</span><br><span class="line">       mThread = Thread.currentThread();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> 可以看出，Looper 在构造函数中会new 一个消息队列，并将当前的线程赋值给变量，那么，在线程中，我们怎样初始化 Looper呢,先看下下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void run() &#123;</span><br><span class="line">             Looper.prepare();</span><br><span class="line">             Handler handler = new Handler();</span><br><span class="line">             Looper.loop();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;).start();</span><br></pre></td></tr></table></figure></p>
<p>可以看出，通过 Looper.prepare() 就可以创建一个 Looper，并通过 loop 函数开启消息循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">       if (sThreadLocal.get() != null) &#123;</span><br><span class="line">           throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>很清晰的可以看出， 在prepare 中会生成一个新的 Looper 对象，并赋值到线程中。<br>下面我们分析一下最重要的函数 loop 函数，只有调用了 loop 后，消息循环才会正真的起作用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">      final Looper me = myLooper();</span><br><span class="line">      if (me == null) &#123;</span><br><span class="line">          throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      final MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">      Binder.clearCallingIdentity();</span><br><span class="line">      final long ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">      for (;;) &#123;</span><br><span class="line">          Message msg = queue.next(); // might block</span><br><span class="line">          if (msg == null) &#123;</span><br><span class="line">             </span><br><span class="line">              return;</span><br><span class="line">          &#125;</span><br><span class="line">        </span><br><span class="line">          Printer logging = me.mLogging;</span><br><span class="line">          if (logging != null) &#123;</span><br><span class="line">              logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                      msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          msg.target.dispatchMessage(msg);</span><br><span class="line"></span><br><span class="line">          if (logging != null) &#123;</span><br><span class="line">              logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          final long newIdent = Binder.clearCallingIdentity();</span><br><span class="line">          if (ident != newIdent) &#123;</span><br><span class="line">              Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</span><br><span class="line">                      + Long.toHexString(ident) + &quot; to 0x&quot;</span><br><span class="line">                      + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</span><br><span class="line">                      + msg.target.getClass().getName() + &quot; &quot;</span><br><span class="line">                      + msg.callback + &quot; what=&quot; + msg.what);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          msg.recycle();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>loop 方法也比较了解，其方法是一个死循环，唯一跳出循环的条件是 MessageQueue 的next 方法返回了 null，Looper 提供了两种方式来退出 Looper</p>
<ol>
<li>一个是quit，该方法会直接退出 Looper</li>
<li>一个是quitSafely，该方法会设定一个退出标记，然后把消息队列里面的消息全部清理完成后，安全的退出</li>
</ol>
<p>Looper 退出后，handler 在send 一个消息，就会返回false，并且消息对垒被标记位退出后，它的 next 方法就会返回一个 null，也就是说， Looper 必须被退出，否则就会一直不停的循环下去，如果有消息的话，就会调用 msg.target.diapatchMessage 方法，这就形成了一个回调</p>
<p>###MessageQueue<br>MessageQueue 是一个维护消息的队列，所以消息队列的主要方法和普通的队列一样，一个是 插入 一个是读取，对应的方法分别是 enqueueMessage 和 next 方法，其中enqueueMessage 是往队列中插入一个消息，next 是获取一个消息，并删除，看下他们的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">       if (msg.isInUse()) &#123;</span><br><span class="line">           throw new AndroidRuntimeException(msg + &quot; This message is already in use.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       if (msg.target == null) &#123;</span><br><span class="line">           throw new AndroidRuntimeException(&quot;Message must have a target.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       synchronized (this) &#123;</span><br><span class="line">           if (mQuitting) &#123;</span><br><span class="line">               RuntimeException e = new RuntimeException(</span><br><span class="line">                       msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">               Log.w(&quot;MessageQueue&quot;, e.getMessage(), e);</span><br><span class="line">               return false;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           msg.when = when;</span><br><span class="line">           Message p = mMessages;</span><br><span class="line">           boolean needWake;</span><br><span class="line"></span><br><span class="line">		//此处为 MessageQueue 的核心代码，主要就是插入一个消息到链表中</span><br><span class="line">           if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">               </span><br><span class="line">               msg.next = p;</span><br><span class="line">               mMessages = msg;</span><br><span class="line">               needWake = mBlocked;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               </span><br><span class="line">               needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">               Message prev;</span><br><span class="line">               for (;;) &#123;</span><br><span class="line">                   prev = p;</span><br><span class="line">                   p = p.next;</span><br><span class="line">                   if (p == null || when &lt; p.when) &#123;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">                   if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                       needWake = false;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">			//将消息队列的后续设为 p</span><br><span class="line">			//并将消息插入到队尾</span><br><span class="line">               msg.next = p; // invariant: p == prev.next</span><br><span class="line">               prev.next = msg;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // We can assume mPtr != 0 because mQuitting is false.</span><br><span class="line">           if (needWake) &#123;</span><br><span class="line">               nativeWake(mPtr);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>next 方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">       int pendingIdleHandlerCount = -1; // -1 only during first iteration</span><br><span class="line">       int nextPollTimeoutMillis = 0;</span><br><span class="line">       for (;;) &#123;</span><br><span class="line">           if (nextPollTimeoutMillis != 0) &#123;</span><br><span class="line">               Binder.flushPendingCommands();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           nativePollOnce(mPtr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">           synchronized (this) &#123;</span><br><span class="line">            </span><br><span class="line">               final long now = SystemClock.uptimeMillis();</span><br><span class="line">               Message prevMsg = null;</span><br><span class="line">               Message msg = mMessages;</span><br><span class="line">               if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">                </span><br><span class="line">                   do &#123;</span><br><span class="line">                       prevMsg = msg;</span><br><span class="line">                       msg = msg.next;</span><br><span class="line">                   &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">			//在消息队列中取出一个消息</span><br><span class="line">               if (msg != null) &#123;</span><br><span class="line">                   if (now &lt; msg.when) &#123;</span><br><span class="line">                      </span><br><span class="line">                       nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       // Got a message.</span><br><span class="line">                       mBlocked = false;</span><br><span class="line">                       if (prevMsg != null) &#123;</span><br><span class="line">                           prevMsg.next = msg.next;</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           mMessages = msg.next;</span><br><span class="line">                       &#125;</span><br><span class="line">                       msg.next = null;</span><br><span class="line">                       if (false) Log.v(&quot;MessageQueue&quot;, &quot;Returning message: &quot; + msg);</span><br><span class="line">                       msg.markInUse();</span><br><span class="line">                       return msg;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   // No more messages.</span><br><span class="line">                   nextPollTimeoutMillis = -1;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (mQuitting) &#123;</span><br><span class="line">                   dispose();</span><br><span class="line">                   return null;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (pendingIdleHandlerCount &lt; 0</span><br><span class="line">                       &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</span><br><span class="line">                   pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">               &#125;</span><br><span class="line">               if (pendingIdleHandlerCount &lt;= 0) &#123;</span><br><span class="line">                   // No idle handlers to run.  Loop and wait some more.</span><br><span class="line">                   mBlocked = true;</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (mPendingIdleHandlers == null) &#123;</span><br><span class="line">                   mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</span><br><span class="line">               &#125;</span><br><span class="line">               mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">               final IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">               mPendingIdleHandlers[i] = null; // release the reference to the handler</span><br><span class="line"></span><br><span class="line">               boolean keep = false;</span><br><span class="line">               try &#123;</span><br><span class="line">                   keep = idler.queueIdle();</span><br><span class="line">               &#125; catch (Throwable t) &#123;</span><br><span class="line">                   Log.wtf(&quot;MessageQueue&quot;, &quot;IdleHandler threw exception&quot;, t);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (!keep) &#123;</span><br><span class="line">                   synchronized (this) &#123;</span><br><span class="line">                       mIdleHandlers.remove(idler);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           pendingIdleHandlerCount = 0;</span><br><span class="line"></span><br><span class="line">           nextPollTimeoutMillis = 0;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>next 就是一个无限循环的方法，如果对垒中没有消息，就会阻塞在这里，当有新的消息到来时，就会返回这条消息并将其从链表中移除</p>
<p>  参考资料：<br>  <a href="http://www.jianshu.com/p/51143c25e6fe" target="_blank" rel="external">ThreadLocal</a></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="/2016/04/27/android-线程解析/#comment" class="comment-link">评论</a>
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
  
  <div class="tags">
    <a href="/tags/android-Handler/">android Handler</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-android-线程解析" data-title="android 线程解析" data-url="http://yoursite.com/2016/04/27/android-线程解析/"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
  var duoshuoQuery = {short_name:'huronghui'};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
       || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
  <!-- 多说公共JS代码 end -->

</section>


</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/blog/">blog</a><small>5</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2016/04/27/android-线程解析/">android 线程解析</a>
      </li>
    
      <li>
        <a href="/2016/04/25/GreenDao-初步使用/">GreenDao 初步使用</a>
      </li>
    
      <li>
        <a href="/2016/04/23/RecyclerView-初始以及设置点击事件/">RecyclerView 初始以及设置点击事件（一）</a>
      </li>
    
      <li>
        <a href="/2016/04/21/Service-分析/">Service 分析</a>
      </li>
    
      <li>
        <a href="/2016/04/20/Window-View-关系梳理/">Window View 关系梳理</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/android-GreenDao/">android GreenDao</a><small>1</small></li>
  
    <li><a href="/tags/android-Handler/">android Handler</a><small>1</small></li>
  
    <li><a href="/tags/android-RecyclerView/">android RecyclerView</a><small>1</small></li>
  
    <li><a href="/tags/android-View/">android View</a><small>1</small></li>
  
    <li><a href="/tags/android-activity/">android activity</a><small>1</small></li>
  
    <li><a href="/tags/android-service/">android service</a><small>1</small></li>
  
    <li><a href="/tags/android-window/">android window</a><small>2</small></li>
  
    <li><a href="/tags/android-事件分发/">android 事件分发</a><small>2</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/android-GreenDao/" style="font-size: 10px;">android GreenDao</a> <a href="/tags/android-Handler/" style="font-size: 10px;">android Handler</a> <a href="/tags/android-RecyclerView/" style="font-size: 10px;">android RecyclerView</a> <a href="/tags/android-View/" style="font-size: 10px;">android View</a> <a href="/tags/android-activity/" style="font-size: 10px;">android activity</a> <a href="/tags/android-service/" style="font-size: 10px;">android service</a> <a href="/tags/android-window/" style="font-size: 20px;">android window</a> <a href="/tags/android-事件分发/" style="font-size: 20px;">android 事件分发</a>
  </div>
</div>


  <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=5&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=2203673484&verifier=607c53d8&dpc=1"></iframe>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2016 huronghui
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id='bg'></div>
</body>
</html>