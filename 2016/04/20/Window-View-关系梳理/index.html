<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  
  <title>Window View 关系梳理 | 霜白</title>
  <meta name="author" content="huronghui" />

  
  <meta name="description" content="android" />
  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <meta property="og:title" content="Window View 关系梳理" />
  <meta property="og:site_name" content="霜白" />

  
  

  
    <meta property="og:image" content="undefined" />
  

  
  <link href="/css/images/favicon.ico" rel="icon" />
  

  <link rel="alternate" href="/atom.xml" title="霜白" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">霜白</a></h1>
  <h2><a href="/">栀年年年</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-20T05:36:55.000Z"><a href="/2016/04/20/Window-View-关系梳理/">2016-04-20</a></time>
      
      
  
    <h1 class="title">Window View 关系梳理</h1>
  

    </header>
    <div class="entry">
      
        <p>还记得我们之前分析的activity 的启动过程么？<br>我们那时只是分析到了 activity 的oncreate() 过程，并且从我们的分析过程中也可以看到，界面显示在activity的代码没有，那么到底是在什么时候，view 的视图显示在activity 上面的呢？所以，本文的主要目的就是沿着之前的activity的启动流程，分析一下界面的显示过程。<br>前面我们分析过，在oncreate() 的 setContentView() 这个函数是将我们写的View 视图放入一个DecorView 的ViewGroup容器里面，并且我们也分析到了，这个DecorView 就是我们的视图根目录，好比说，DecorView 是我们视图树的根节点，并且这个DecorView 是PhoneWindw 类的一个内部类，那么是PhoneWindow 来管理这个DecorView的么？<br>源码会告诉我们一切，我们接着之前的分析，在activty的启动过程中，我们分析到了 handleLaunchActivity，并继续跟踪里面的 performLaunchActivity() 这个函数，我们看下源码：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">   //获取要启动的activity的信息</span><br><span class="line">       ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">       </span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">   //此处开始新建一个activity</span><br><span class="line">       activity = mInstrumentation.newActivity(</span><br><span class="line">       cl, component.getClassName(), r.intent);</span><br><span class="line">       </span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">   //创建 application 对象，先执行 attach 在执行oncreate()</span><br><span class="line">       Application app = r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">       </span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">   //调用 attach 函数，将 applicaiton，Instrumentation，parent 等和 activity 进行绑定</span><br><span class="line">       activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent,r.embeddedID, r.lastNonConfigurationInstances, config);</span><br><span class="line">       </span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">   //调用 Instrumentation 的create 函数</span><br><span class="line">       mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">       </span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">   //当activity 不是finish的时候，我们开始执行 start()函数</span><br><span class="line">               if (!r.activity.mFinished) &#123;</span><br><span class="line">                   activity.performStart();</span><br><span class="line">                   r.stopped = false;</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">//恢复之前存储的数据，调用 performRestoreInstanceState 函数</span><br><span class="line">               if (!r.activity.mFinished) &#123;</span><br><span class="line">                   if (r.state != null) &#123;                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure>
<p> 代码很简洁，但也很重要，因为在performLaunchActivity 函数中，我们绑定了很多重要的服务，但同时我们也没有发现在这个函数中任何和界面有关的信息，所以我们需要返回回调之前的函数中寻找答案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line"></span><br><span class="line">        ....</span><br><span class="line">        </span><br><span class="line">        //开始执行 activity 的oncreate()函数</span><br><span class="line">        Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line">        </span><br><span class="line">        if (a != null) &#123;</span><br><span class="line">            r.createdConfig = new Configuration(mConfiguration);</span><br><span class="line">            Bundle oldState = r.state;</span><br><span class="line"></span><br><span class="line">			// 执行 resume 操作，将当前的View显示在activity中</span><br><span class="line">            handleResumeActivity(r.token, false, r.isForward,</span><br><span class="line">                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed);</span><br><span class="line">                    </span><br><span class="line">            ....</span><br><span class="line">            </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ActivityManagerNative.getDefault()</span><br><span class="line">                    .finishActivity(r.token, Activity.RESULT_CANCELED, null);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p> 我们发现，在我们之前分析的 performLaunchActivity 函数后面还有一个判断语句，就是当我们执行完performLaunchActivity后，如果 activity 没有finish 的话，我们会执行 handleResumeActivity 函数，发现这个函数，是不是很激动，貌似又要和我们的一个熟悉的函数 onResume() 联系在一起了,来，看下这个函数的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) &#123;</span><br><span class="line"> </span><br><span class="line"> //执行activity的onResume操作，但此处还没有显示出界面，真正的显示是在下面开始</span><br><span class="line">       ActivityClientRecord r = performResumeActivity(token, clearHide);</span><br><span class="line">       </span><br><span class="line">        if (r != null) &#123;</span><br><span class="line">        </span><br><span class="line">   //此处为关键，我们会获取到我们activity中 attach 的window，并通过WMS 获取到 DecorView</span><br><span class="line">//通过 DecorView 这个顶节点来 addView 至 WM中，这个DecorView 在Oncreate() 函数中已经通过</span><br><span class="line">//setContentView()把我们的要填充的界面放入了 DecorView 中。</span><br><span class="line">           if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">               r.window = r.activity.getWindow();</span><br><span class="line">               View decor = r.window.getDecorView();</span><br><span class="line">               decor.setVisibility(View.INVISIBLE);</span><br><span class="line">               ViewManager wm = a.getWindowManager();</span><br><span class="line">               WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">               a.mDecor = decor;</span><br><span class="line">               l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">               l.softInputMode |= forwardBit;</span><br><span class="line">               if (a.mVisibleFromClient) &#123;</span><br><span class="line">                   a.mWindowAdded = true;</span><br><span class="line">                   wm.addView(decor, l);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p> 看到这是不是觉得恍然大悟了，我们的发现最关键的几个类，View, ViewManager， windowManager等等，直觉会告诉你，没错，这儿就是我们 activity 显示界面的地方，我们分析 12 行开始每一句话：</p>
<ul>
<li>12行代码，首先是获取到我们当前activity 的 Window 对象，其实就是我们之前所说 PhoneWindow 类的实例</li>
<li>13行代码，这个也很清楚，就是获得DecorView</li>
<li>14行代码，这很关键，通过setVisibility函数使得 DecorView 能够显示</li>
<li>15行代码，获取到一个ViewManager 对象，a 是 r.activity 也就是我们的acticity 实例</li>
<li>16行代码，设置 WindowManager.LayoutParams 属性</li>
<li>接下来没什么很重要的设置，直接跳到22行，addView 这个函数，有经验的人就知道了，这个就是添加 View 视图的地方，也就是说，这行代码是实现了帮我们写的View视图添加到我们的目的activity 的视图管理中</li>
</ul>
<p>至此，我们应该明白了activity 的流程了，</p>
<ul>
<li>在oncreate 中，我们把我们的View 添加到 DecorView 的一个id为content的framelayout 中</li>
<li>在执行完 onresume 后，我们会获得 WM(WindowManager)添加DecoView，从而显示视图</li>
</ul>
<p>我们开一看出，添加一个View 需要上面几个类的支持，那么是时候来分析一般这些类了， Window 的添加过程是需要 WindowManager 的 addView 来实现的，WindowManager 是一个接口，他的真正实现是在 WindowManagerImpl 类中，具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line">    public void addView(View view, ViewGroup.LayoutParams params) &#123;</span><br><span class="line">        mGlobal.addView(view, params, mDisplay, mParentWindow);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">@Override</span><br><span class="line">    public void removeView(View view) &#123;</span><br><span class="line">        mGlobal.removeView(view, false);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> @Override</span><br><span class="line">    public void updateViewLayout(View view, ViewGroup.LayoutParams params) &#123;</span><br><span class="line">        mGlobal.updateViewLayout(view, params);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p> 可以看出 WindowManagerImpl 并没有直接实现 Window 的三大操作，而是交给了一个WindowManagerGlobal 的类来进行处理，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static WindowManagerGlobal getInstance() &#123;</span><br><span class="line">       synchronized (WindowManagerGlobal.class) &#123;</span><br><span class="line">           if (sDefaultWindowManager == null) &#123;</span><br><span class="line">               sDefaultWindowManager = new WindowManagerGlobal();</span><br><span class="line">           &#125;</span><br><span class="line">           return sDefaultWindowManager;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> 可以看出 WindowManagerGlobal 是以工厂的方式来提供自己实例，而WindowManagerImpl 的这种实现方式是一种典型的桥接模式，自身不实现任何操作，将操作全部委托给另外一个类。</p>
<p>##先分析一下addView的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void addView(View view, ViewGroup.LayoutParams params,</span><br><span class="line">           Display display, Window parentWindow) &#123;</span><br><span class="line">           </span><br><span class="line">           ...</span><br><span class="line">           </span><br><span class="line">           final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;</span><br><span class="line">       if (parentWindow != null) &#123;</span><br><span class="line">           parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ViewRootImpl root;</span><br><span class="line">       View panelParentView = null;</span><br><span class="line">       </span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">        root = new ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">           view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">           mViews.add(view);</span><br><span class="line">           mRoots.add(root);</span><br><span class="line">           mParams.add(wparams);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">           root.setView(view, wparams, panelParentView);</span><br><span class="line">       &#125; </span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></p>
<p>在 WindowManagerGlobal 类中有这么几个列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;();</span><br><span class="line">private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;();</span><br><span class="line">private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams =</span><br><span class="line">            new ArrayList&lt;WindowManager.LayoutParams&gt;();</span><br><span class="line">private final ArraySet&lt;View&gt; mDyingViews = new ArraySet&lt;View&gt;();</span><br></pre></td></tr></table></figure></p>
<p> 这几个list 是WindowManagerGlobal 管理View 的核心所在，从前面的 addView 函数可以看出，最后正真执行这些 add 操作的其实就是这些 View 的列表，其中</p>
<ol>
<li>mViews 存储的是所有window 所对应的View</li>
<li>mRoots 存储的是所有Window 所对应的 ViewRootImpl</li>
<li>mParams 存储的是所有Window 所对应的布局参数</li>
<li>mDyingViews 存储的是那些正在被删除的View 对象，或者说是哪些已经调用了removeView 但是还未完成的Window 对象 （以上来源与 《android 开发艺术探索》 第八章）</li>
</ol>
<p>然后就是最关键的 setView 方法了，这是 ViewRootImpl 的一个方法，我们进入代码看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        //此处会绘制函数的入口</span><br><span class="line">        requestLayout();</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        try &#123;</span><br><span class="line">        mOrigWindowType = mWindowAttributes.type;</span><br><span class="line">        mAttachInfo.mRecomputeGlobalAttributes = true;</span><br><span class="line">        collectViewAttributes();</span><br><span class="line">        res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">mAttachInfo.mContentInsets, mInputChannel);</span><br><span class="line">    &#125; </span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">    public void requestLayout() &#123;</span><br><span class="line">        if (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">            checkThread();</span><br><span class="line">            mLayoutRequested = true;</span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>，<br>接着会调用 WindowSession 来把当前的View 实现最终添加的过程，mWindowSession 是一个Binder 对象，真正的实现类是 Session，也就是说Window 的添加过程实际上是一次 IPC 调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs,int viewVisibility, int displayId, Rect outContentInsets,InputChannel outInputChannel) &#123;</span><br><span class="line">        return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId,outContentInsets, outInputChannel);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p> 可以看出 Window 的天际请求会调用 WinddowManagerService 去处理了，后面的处理就深入到底层了，我们就不一一探讨了。</p>
<h2 id="分析一下-removeView-的过程"><a href="#分析一下-removeView-的过程" class="headerlink" title="分析一下 removeView 的过程"></a>分析一下 removeView 的过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public void removeView(View view, boolean immediate) &#123;</span><br><span class="line">        if (view == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;view must not be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            int index = findViewLocked(view, true);</span><br><span class="line">            View curView = mRoots.get(index).getView();</span><br><span class="line">            removeViewLocked(index, immediate);</span><br><span class="line">            if (curView == view) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            throw new IllegalStateException(&quot;Calling with view &quot; + view + &quot; but the ViewAncestor is attached to &quot; + curView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">     private void removeViewLocked(int index, boolean immediate) &#123;</span><br><span class="line">        ViewRootImpl root = mRoots.get(index);</span><br><span class="line">        View view = root.getView();</span><br><span class="line"></span><br><span class="line">        if (view != null) &#123;</span><br><span class="line">            InputMethodManager imm = InputMethodManager.getInstance();</span><br><span class="line">            if (imm != null) &#123;</span><br><span class="line">                imm.windowDismissed(mViews.get(index).getWindowToken());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean deferred = root.die(immediate);</span><br><span class="line">        if (view != null) &#123;</span><br><span class="line">            view.assignParent(null);</span><br><span class="line">            if (deferred) &#123;</span><br><span class="line">                mDyingViews.add(view);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 思路很简单：</p>
<ul>
<li>先通过findViewLocked 来找到 待删除的 View 的索引，在调用 removeViewLocked 来做进一步的删除，removeViewLocked 是通过 ViewRootInpl 来完成删除</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">boolean die(boolean immediate) &#123;</span><br><span class="line"></span><br><span class="line">		//做简单判断，如果是异步删除，那么就发送一个MSG_DIE 的消息</span><br><span class="line">		//ViewRootImpl 中的 Handler 会处理此消息并调用 doDie()</span><br><span class="line">		//如果是同步删除，就不发送消息，直接进行doDie()操作</span><br><span class="line">        if (immediate &amp;&amp; !mIsInTraversal) &#123;</span><br><span class="line">            doDie();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!mIsDrawing) &#123;</span><br><span class="line">            destroyHardwareRenderer();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Log.e(TAG, &quot;Attempting to destroy the window while drawing!\n&quot; +&quot;  window=&quot; + this + &quot;, title=&quot; + mWindowAttributes.getTitle());</span><br><span class="line">        &#125;</span><br><span class="line">        mHandler.sendEmptyMessage(MSG_DIE);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    void doDie() &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        if (LOCAL_LOGV) Log.v(TAG, &quot;DIE in &quot; + this + &quot; of &quot; + mSurface);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mRemoved) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            mRemoved = true;</span><br><span class="line">            if (mAdded) &#123;</span><br><span class="line"></span><br><span class="line">				//此处为真正的删除地方</span><br><span class="line">                dispatchDetachedFromWindow();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mAdded &amp;&amp; !mFirst) &#123;</span><br><span class="line">                invalidateDisplayLists();</span><br><span class="line">                destroyHardwareRenderer();</span><br><span class="line"></span><br><span class="line">                if (mView != null) &#123;</span><br><span class="line">                    int viewVisibility = mView.getVisibility();</span><br><span class="line">                    boolean viewVisibilityChanged = mViewVisibility != viewVisibility;</span><br><span class="line">                    if (mWindowAttributesChanged || viewVisibilityChanged) &#123;</span><br><span class="line">                        </span><br><span class="line">                        try &#123;</span><br><span class="line">                            if ((relayoutWindow(mWindowAttributes, viewVisibility, false)</span><br><span class="line">                                    &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) &#123;</span><br><span class="line">                                mWindowSession.finishDrawing(mWindow);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    mSurface.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mAdded = false;</span><br><span class="line">        &#125;</span><br><span class="line">        WindowManagerGlobal.getInstance().doRemoveView(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>###更新操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void updateViewLayout(View view, ViewGroup.LayoutParams params) &#123;</span><br><span class="line">       if (view == null) &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;view must not be null&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       if (!(params instanceof WindowManager.LayoutParams)) &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;</span><br><span class="line"></span><br><span class="line">       view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">       synchronized (mLock) &#123;</span><br><span class="line">           int index = findViewLocked(view, true);</span><br><span class="line">           ViewRootImpl root = mRoots.get(index);</span><br><span class="line">           mParams.remove(index);</span><br><span class="line">           mParams.add(index, wparams);</span><br><span class="line">           root.setLayoutParams(wparams, false);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> 更新的方法做的就比较简单了，首先它是更新了 View 的LayoutParams 并替换到之前的 LayoutParams，在更新 ViewRootImpl 中的LayoutParams，这一步是通过 setLayoutParams 方法来实现的，这本身也是一次 IPC 过程。<br> 到此 Windwow 和 View 的关系应该就明了了：</p>
<ol>
<li>Window 不会直接管理 View</li>
<li>Window 通过 ViewRoot 来实现View 的绘制</li>
<li>Window 的View 管理是 WindowManager 并且管理的也是 View 而不是Window。</li>
</ol>
<p>ps:下面是 Dialog 和 Toast 的一下特性：</p>
<p>##Dialog：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Dialog dialog = new Dialog(TestActivity.this);</span><br><span class="line"></span><br><span class="line">TextView textView = new TextView(TestActivity.this);</span><br><span class="line">textView.setText(&quot;test&quot;);</span><br><span class="line"></span><br><span class="line">dialog.setContentView(textView);</span><br><span class="line"></span><br><span class="line">dialog.show();</span><br></pre></td></tr></table></figure></p>
<p> 上面的代码是一个典型的显示 Dialog 的代码，和activity 中显示布局一样，都是创建 Window，初始化 DecorView ，并通过 setContentView 显示布局，但有一个特殊之处就是 <strong>初始化 Dialog 的时候，传入的必须是 activity 的context，否则会报错 ，但如果是指定系统类型的对话框就不需要这样</strong>，</p>
<p>##Toast</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static Toast makeText(Context context, CharSequence text, int duration) &#123;</span><br><span class="line">       Toast result = new Toast(context);</span><br><span class="line">       LayoutInflater inflate = (LayoutInflater)</span><br><span class="line">               context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">	//很明显的可以看出 Toast 和 Window 一样，都是调用系统布局，添加到 Window 中</span><br><span class="line">       View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null);</span><br><span class="line">       TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message);</span><br><span class="line">       tv.setText(text);</span><br><span class="line">       result.mNextView = v;</span><br><span class="line">       result.mDuration = duration;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Toast 需要注意的是，但他的显示过程中，因为涉及到定时取消的问题，用到了 Handler，所以这就意味着 Toast 无法再没有 Looper 的线程中弹出,<br>并且 Toast 是将我们的信息封装成一个 ToastRecord 到一个 Queue，该Queue能够同时存在 50个 Record，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void showNextToastLocked() &#123;</span><br><span class="line">        ToastRecord record = mToastQueue.get(0);</span><br><span class="line">        while (record != null) &#123;</span><br><span class="line">           ...</span><br><span class="line">            try &#123;</span><br><span class="line">                record.callback.show();</span><br><span class="line">                scheduleTimeoutLocked(record);</span><br><span class="line">                return;</span><br><span class="line">            &#125; </span><br><span class="line">            ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     private void scheduleTimeoutLocked(ToastRecord r)</span><br><span class="line">    &#123;</span><br><span class="line">        mHandler.removeCallbacksAndMessages(r);</span><br><span class="line">        Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r);</span><br><span class="line">        long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY;</span><br><span class="line">        mHandler.sendMessageDelayed(m, delay);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p> 在此我们可以看见此处就是我们设置延时时间的地方，隐藏也是通过 hide 函数来实现的，通过Handle 发送一个信息来控制显示的事件，具体会调用如下函数来实现取消显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void cancelToastLocked(int index) &#123;</span><br><span class="line">     ToastRecord record = mToastQueue.get(index);</span><br><span class="line">     try &#123;</span><br><span class="line">         record.callback.hide();</span><br><span class="line">     &#125; catch (RemoteException e) &#123;</span><br><span class="line">         Slog.w(TAG, &quot;Object died trying to hide notification &quot; + record.callback</span><br><span class="line">                 + &quot; in package &quot; + record.pkg);</span><br><span class="line">     &#125;</span><br><span class="line">     mToastQueue.remove(index);</span><br><span class="line">     keepProcessAliveLocked(record.pid);</span><br><span class="line">     if (mToastQueue.size() &gt; 0) &#123;</span><br><span class="line">         showNextToastLocked();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p> 也是和显示一样，通过 NMS 跨进程的方式，调用了 hide 函数来隐藏。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="/2016/04/20/Window-View-关系梳理/#comment" class="comment-link">评论</a>
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
  
  <div class="tags">
    <a href="/tags/android-window/">android window</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-Window-View-关系梳理" data-title="Window View 关系梳理" data-url="http://yoursite.com/2016/04/20/Window-View-关系梳理/"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
  var duoshuoQuery = {short_name:'huronghui'};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
       || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
  <!-- 多说公共JS代码 end -->

</section>


</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/blog/">blog</a><small>5</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2016/04/21/Service-分析/">Service 分析</a>
      </li>
    
      <li>
        <a href="/2016/04/20/Window-View-关系梳理/">Window View 关系梳理</a>
      </li>
    
      <li>
        <a href="/2016/04/18/activity-事件分发过程/">activity 事件分发过程</a>
      </li>
    
      <li>
        <a href="/2016/04/16/activity-的启动/">activity 的启动</a>
      </li>
    
      <li>
        <a href="/2016/04/14/setContentView-解析/">setContentView 解析</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/android-View/">android View</a><small>1</small></li>
  
    <li><a href="/tags/android-activity/">android activity</a><small>1</small></li>
  
    <li><a href="/tags/android-service/">android service</a><small>1</small></li>
  
    <li><a href="/tags/android-window/">android window</a><small>2</small></li>
  
    <li><a href="/tags/android-事件分发/">android 事件分发</a><small>2</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/android-View/" style="font-size: 10px;">android View</a> <a href="/tags/android-activity/" style="font-size: 10px;">android activity</a> <a href="/tags/android-service/" style="font-size: 10px;">android service</a> <a href="/tags/android-window/" style="font-size: 20px;">android window</a> <a href="/tags/android-事件分发/" style="font-size: 20px;">android 事件分发</a>
  </div>
</div>


  <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=5&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=2203673484&verifier=607c53d8&dpc=1"></iframe>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2016 huronghui
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id='bg'></div>
</body>
</html>